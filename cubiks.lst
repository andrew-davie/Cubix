------- FILE cubiks.asm LEVEL 1 PASS 2
      1 U0fcc ????						; Derived from CDFJ shell/demo by Darrel Spice Jr.
      2 U0fcc ????						; Cubicks code (c) 2021 Andrew Davie
      3 U0fcc ????
      4 U0fcc ????						; REMEMBER cannot use lda # as this is overloaded for datastream access!!
      5 U0fcc ????						; use ldx # or ldy # instead
      6 U0fcc ????
      7 U0fcc ????				      PROCESSOR	6502
------- FILE vcs.h LEVEL 2 PASS 2
      0 U0fcc ????				      include	"vcs.h"
      1 U0fcc ????						; VCS.H
      2 U0fcc ????						; Version 1.05, 13/November/2003
      3 U0fcc ????
      4 U0fcc ????	       00 69	   VERSION_VCS =	105
      5 U0fcc ????
      6 U0fcc ????						; THIS IS A PRELIMINARY RELEASE OF *THE* "STANDARD" VCS.H
      7 U0fcc ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      8 U0fcc ????						; PLEASE DO *NOT* REDISTRIBUTE THIS FILE!
      9 U0fcc ????						;
     10 U0fcc ????						; This file defines hardware registers and memory mapping for the
     11 U0fcc ????						; Atari 2600. It is distributed as a companion machine-specific support package
     12 U0fcc ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     13 U0fcc ????						; available at at http://www.atari2600.org/dasm
     14 U0fcc ????						;
     15 U0fcc ????						; Many thanks to the original author(s) of this file, and to everyone who has
     16 U0fcc ????						; contributed to understanding the Atari 2600.  If you take issue with the
     17 U0fcc ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     18 U0fcc ????						; with your views.  Please contribute, if you think you can improve this
     19 U0fcc ????						; file!
     20 U0fcc ????						;
     21 U0fcc ????						; Latest Revisions...
     22 U0fcc ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     23 U0fcc ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     24 U0fcc ????						;			    This will allow conditional code to verify VCS.H being
     25 U0fcc ????						;			    used for code assembly.
     26 U0fcc ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     27 U0fcc ????						;			 convenient disassembly/reassembly compatibility for hardware
     28 U0fcc ????						;			 mirrored reading/writing differences.	This is more a 
     29 U0fcc ????						;			 readability issue, and binary compatibility with disassembled
     30 U0fcc ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     31 U0fcc ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     32 U0fcc ????						;			 which was broken by the use of segments in this file, as
     33 U0fcc ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     34 U0fcc ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     35 U0fcc ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     36 U0fcc ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     37 U0fcc ????						;						   it is safe to leave it undefined, and the base address will
     38 U0fcc ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     39 U0fcc ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     40 U0fcc ????						;			  - register definitions are now generated through assignment
     41 U0fcc ????						;			    in uninitialised segments.	This allows a changeable base
     42 U0fcc ????						;			    address architecture.
     43 U0fcc ????						; 1.0	22/MAR/2003		Initial release
     44 U0fcc ????
     45 U0fcc ????
     46 U0fcc ????						;-------------------------------------------------------------------------------
     47 U0fcc ????
     48 U0fcc ????						; TIA_BASE_ADDRESS
     49 U0fcc ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     50 U0fcc ????						; Normally 0, the base address should (externally, before including this file)
     51 U0fcc ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     52 U0fcc ????						; The reason is that this bankswitching scheme treats any access to locations
     53 U0fcc ????						; < $40 as a bankswitch.
     54 U0fcc ????
     55 U0fcc ????			  -	      IFNCONST	TIA_BASE_ADDRESS
     56 U0fcc ????			  -TIA_BASE_ADDRESS =	0
     57 U0fcc ????				      ENDIF
     58 U0fcc ????
     59 U0fcc ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     60 U0fcc ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     61 U0fcc ????						; *OR* by declaring the label before including this file, eg:
     62 U0fcc ????						; TIA_BASE_ADDRESS = $40
     63 U0fcc ????						;   include "vcs.h"
     64 U0fcc ????
     65 U0fcc ????						; Alternate read/write address capability - allows for some disassembly compatibility
     66 U0fcc ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     67 U0fcc ????						; for the mirrored ROM hardware registers.
     68 U0fcc ????
     69 U0fcc ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     70 U0fcc ????						; using the -D command-line switch, as required.  If the addresses are not defined, 
     71 U0fcc ????						; they defaut to the TIA_BASE_ADDRESS.
     72 U0fcc ????
     73 U0fcc ????			  -	      IFNCONST	TIA_BASE_READ_ADDRESS
     74 U0fcc ????			  -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     75 U0fcc ????				      ENDIF
     76 U0fcc ????
     77 U0fcc ????			  -	      IFNCONST	TIA_BASE_WRITE_ADDRESS
     78 U0fcc ????			  -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     79 U0fcc ????				      ENDIF
     80 U0fcc ????
     81 U0fcc ????						;-------------------------------------------------------------------------------
     82 U0fcc ????
     83 U002d ????				      SEG.U	TIA_REGISTERS_WRITE
     84 U0000					      ORG	TIA_BASE_WRITE_ADDRESS
     85 U0000
     86 U0000							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     87 U0000
     88 U0000		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     89 U0001		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     90 U0002		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     91 U0003		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     92 U0004		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     93 U0005		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     94 U0006		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     95 U0007		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     96 U0008		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     97 U0009		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
     98 U000a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
     99 U000b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
    100 U000c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
    101 U000d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
    102 U000e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
    103 U000f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    104 U0010		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    105 U0011		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    106 U0012		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    107 U0013		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    108 U0014		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    109 U0015		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    110 U0016		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    111 U0017		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    112 U0018		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    113 U0019		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    114 U001a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    115 U001b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    116 U001c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    117 U001d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    118 U001e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    119 U001f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    120 U0020		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    121 U0021		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    122 U0022		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    123 U0023		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    124 U0024		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    125 U0025		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    126 U0026		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    127 U0027		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    128 U0028		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    129 U0029		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    130 U002a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    131 U002b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    132 U002c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    133 U002d
    134 U002d							;-------------------------------------------------------------------------------
    135 U002d
    136 U000e ????				      SEG.U	TIA_REGISTERS_READ
    137 U0000					      ORG	TIA_BASE_READ_ADDRESS
    138 U0000
    139 U0000							;											bit 7	 bit 6
    140 U0000		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    141 U0001		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    142 U0002		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    143 U0003		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    144 U0004		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    145 U0005		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    146 U0006		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    147 U0007		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    148 U0008		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    149 U0009		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    150 U000a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    151 U000b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    152 U000c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    153 U000d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    154 U000e
    155 U000e							;-------------------------------------------------------------------------------
    156 U000e
    157 U0298 ????				      SEG.U	RIOT
    158 U0280					      ORG	$280
    159 U0280
    160 U0280							; RIOT MEMORY MAP
    161 U0280
    162 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    163 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    164 U0281
    165 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    166 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    167 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    168 U0284		       00	   INTIM      ds	1	; $284		Timer output
    169 U0285
    170 U0285		       00	   TIMINT     ds	1	; $285
    171 U0286
    172 U0286							; Unused/undefined registers ($285-$294)
    173 U0286
    174 U0286		       00		      ds	1	; $286
    175 U0287		       00		      ds	1	; $287
    176 U0288		       00		      ds	1	; $288
    177 U0289		       00		      ds	1	; $289
    178 U028a		       00		      ds	1	; $28A
    179 U028b		       00		      ds	1	; $28B
    180 U028c		       00		      ds	1	; $28C
    181 U028d		       00		      ds	1	; $28D
    182 U028e		       00		      ds	1	; $28E
    183 U028f		       00		      ds	1	; $28F
    184 U0290		       00		      ds	1	; $290
    185 U0291		       00		      ds	1	; $291
    186 U0292		       00		      ds	1	; $292
    187 U0293		       00		      ds	1	; $293
    188 U0294
    189 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    190 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    191 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    192 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    193 U0298
    194 U0298							;-------------------------------------------------------------------------------
    195 U0298							; The following required for back-compatibility with code which does not use
    196 U0298							; segments.
    197 U0298
    198  0000 ????				      SEG
    199  0000 ????
    200  0000 ????						; EOF
------- FILE cubiks.asm
------- FILE macro.h LEVEL 2 PASS 2
      0  0000 ????				      include	"macro.h"
      1  0000 ????						; MACRO.H
      2  0000 ????						; Version 1.07, 2/SEPTEMBER/2013
      3  0000 ????
      4  0000 ????	       00 6b	   VERSION_MACRO =	107	; unoffical version
      5  0000 ????
      6  0000 ????						;
      7  0000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      8  0000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
      9  0000 ????						;
     10  0000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     11  0000 ????						; It is distributed as a companion machine-specific support package
     12  0000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     13  0000 ????						; available at at http://www.atari2600.org/dasm
     14  0000 ????						;
     15  0000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     16  0000 ????						; contents, or would like to add something, please write to me
     17  0000 ????						; (atari2600@taswegian.com) with your contribution.
     18  0000 ????						;
     19  0000 ????						; Latest Revisions...
     20  0000 ????						;
     21  0000 ????						; 1.06  03/SEP/2004	 - nice revision of VERTICAL_BLANK (Edwin Blink)
     22  0000 ????						; 1.05  14/NOV/2003	 - Added VERSION_MACRO equate (which will reflect 100x version #)
     23  0000 ????						;			   This will allow conditional code to verify MACRO.H being
     24  0000 ????						;			   used for code assembly.
     25  0000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     26  0000 ????						;
     27  0000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     28  0000 ????						;
     29  0000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     30  0000 ????						;			   (standardised macro for vertical synch code)
     31  0000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added.
     32  0000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     33  0000 ????						; 1.0	 22/MAR/2003	 Initial release
     34  0000 ????
     35  0000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage,
     36  0000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     37  0000 ????						;   If you do not allow illegal opcode usage, you must include this file
     38  0000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     39  0000 ????						;   registers and require them to be defined first).
     40  0000 ????
     41  0000 ????						; Available macros...
     42  0000 ????						;   SLEEP n		 - sleep for n cycles
     43  0000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     44  0000 ????						;   CLEAN_START	 - set machine to known state on startup
     45  0000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     46  0000 ????
     47  0000 ????						;-------------------------------------------------------------------------------
     48  0000 ????						; SLEEP duration
     49  0000 ????						; Original author: Thomas Jentzsch
     50  0000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     51  0000 ????						; useful for code where precise timing is required.
     52  0000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     53  0000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     54  0000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     55  0000 ????
     56  0000 ????				      MAC	sleep
     57  0000 ????			   .CYCLES    SET	{1}
     58  0000 ????
     59  0000 ????				      IF	.CYCLES < 2
     60  0000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     61  0000 ????				      ERR
     62  0000 ????				      ENDIF
     63  0000 ????
     64  0000 ????				      IF	.CYCLES & 1
     65  0000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     66  0000 ????				      nop	0
     67  0000 ????				      ELSE
     68  0000 ????				      bit	VSYNC
     69  0000 ????				      ENDIF
     70  0000 ????			   .CYCLES    SET	.CYCLES - 3
     71  0000 ????				      ENDIF
     72  0000 ????
     73  0000 ????				      REPEAT	.CYCLES / 2
     74  0000 ????				      nop
     75  0000 ????				      REPEND
     76  0000 ????				      ENDM		;usage: SLEEP n (n>1)
     77  0000 ????
     78  0000 ????						;-------------------------------------------------------------------------------
     79  0000 ????						; VERTICAL_SYNC
     80  0000 ????						; revised version by Edwin Blink -- saves bytes!
     81  0000 ????						; Inserts the code required for a proper 3 scanline vertical sync sequence
     82  0000 ????						; Note: Alters the accumulator
     83  0000 ????
     84  0000 ????						; OUT: A = 0
     85  0000 ????
     86  0000 ????				      MAC	vertical_sync
     87  0000 ????				      lda	#%1110	; each '1' bits generate a VSYNC ON line (bits 1..3)
     88  0000 ????			   .VSLP1     sta	WSYNC	; 1st '0' bit resets Vsync, 2nd '0' bit exit loop
     89  0000 ????				      sta	VSYNC
     90  0000 ????				      lsr
     91  0000 ????				      bne	.VSLP1	; branch until VYSNC has been reset
     92  0000 ????				      ENDM
     93  0000 ????
     94  0000 ????						;-------------------------------------------------------------------------------
     95  0000 ????						; CLEAN_START
     96  0000 ????						; Original author: Omegamatrix
     97  0000 ????						; - Minimal bytes used to set stack pointer, Clear RIOT ram and TIA registers
     98  0000 ????						; - Uses no illegal opcodes.
     99  0000 ????						; - Finishes with SP=$FF, X=0, A=0, Y=0
    100  0000 ????						; - Jumps between operator and operand to perform ASL until A=0, TIA registers
    101  0000 ????						;   finally get cleared at their mirrored locations ($40 and up).
    102  0000 ????						; - SEI is unnecessary and can be cut because the 2600 has no interrupt line.
    103  0000 ????						; - TAY at the end is not really necessary, and can also be cut.
    104  0000 ????
    105  0000 ????				      MAC	clean_start
    106  0000 ????				      sei
    107  0000 ????				      cld
    108  0000 ????			   .CLEAR_STACK
    109  0000 ????				      ldx	#$0A	; ASL opcode = $0A
    110  0000 ????				      inx
    111  0000 ????				      txs
    112  0000 ????				      pha
    113  0000 ????				      bne	.CLEAR_STACK+1	; jump between operator and operand to do ASL
    114  0000 ????				      tay		; SP=$FF, X = A = Y = 0
    115  0000 ????				      ENDM
    116  0000 ????
    117  0000 ????						;-------------------------------------------------------
    118  0000 ????						; SET_POINTER
    119  0000 ????						; Original author: Manuel Rotschkar
    120  0000 ????						;
    121  0000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    122  0000 ????						;
    123  0000 ????						; Usage: SET_POINTER pointer, address
    124  0000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    125  0000 ????						;
    126  0000 ????						; Note: Alters the accumulator, NZ flags
    127  0000 ????						; IN 1: 2 byte RAM location reserved for pointer
    128  0000 ????						; IN 2: absolute address
    129  0000 ????
    130  0000 ????				      MAC	set_pointer
    131  0000 ????			   .POINTER   SET	{1}
    132  0000 ????			   .ADDRESS   SET	{2}
    133  0000 ????
    134  0000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    135  0000 ????				      STA	.POINTER	; Store in pointer
    136  0000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    137  0000 ????				      STA	.POINTER+1	; Store in pointer+1
    138  0000 ????
    139  0000 ????				      ENDM
    140  0000 ????
    141  0000 ????						;-------------------------------------------------------
    142  0000 ????						; BOUNDARY byte#
    143  0000 ????						; Original author: Denis Debro (borrowed from Bob Smith / Thomas)
    144  0000 ????						;
    145  0000 ????						; Push data to a certain position inside a page and keep count of how
    146  0000 ????						; many free bytes the programmer will have.
    147  0000 ????						;
    148  0000 ????						; eg: BOUNDARY 5    ; position at byte #5 in page
    149  0000 ????
    150  0000 ????			   .FREE_BYTES SET	0
    151  0000 ????				      MAC	boundary
    152  0000 ????				      REPEAT	256
    153  0000 ????				      IF	<. % {1} = 0
    154  0000 ????				      MEXIT
    155  0000 ????				      ELSE
    156  0000 ????			   .FREE_BYTES SET	.FREE_BYTES + 1
    157  0000 ????				      .byte	$00
    158  0000 ????				      ENDIF
    159  0000 ????				      REPEND
    160  0000 ????				      ENDM
    161  0000 ????
    162  0000 ????						;-------------------------------------------------------
    163  0000 ????						; SAME PAGE BRANCH CHECK
    164  0000 ????						; Original auther: John Payson
    165  0000 ????						;
    166  0000 ????						; Usage: sbeq, sbne, etc just like a normal beq, bne, etc.
    167  0000 ????						;	  A message will be output if the target of the branch
    168  0000 ????						;	  is not on the same page.
    169  0000 ????						;
    170  0000 ????				      mac	sbcc
    171  0000 ????				      bcc	{1}
    172  0000 ????				      if	(* ^ {1}) & $FF00
    173  0000 ????				      echo	"PAGE CROSSING","WARNING ",{1}," at ",*
    174  0000 ????				      err
    175  0000 ????				      endif
    176  0000 ????				      endm
    177  0000 ????
    178  0000 ????				      mac	sbcs
    179  0000 ????				      bcs	{1}
    180  0000 ????				      if	(* ^ {1}) & $FF00
    181  0000 ????				      echo	"PAGE CROSSING","WARNING ",{1}," at ",*
    182  0000 ????				      err
    183  0000 ????				      endif
    184  0000 ????				      endm
    185  0000 ????
    186  0000 ????				      mac	sbeq
    187  0000 ????				      beq	{1}
    188  0000 ????				      if	(* ^ {1}) & $FF00
    189  0000 ????				      echo	"PAGE CROSSING","WARNING ",{1}," at ",*
    190  0000 ????				      err
    191  0000 ????				      endif
    192  0000 ????				      endm
    193  0000 ????
    194  0000 ????				      mac	sbmi
    195  0000 ????				      bmi	{1}
    196  0000 ????				      if	(* ^ {1}) & $FF00
    197  0000 ????				      echo	"PAGE CROSSING","WARNING ",{1}," at ",*
    198  0000 ????				      err
    199  0000 ????				      endif
    200  0000 ????				      endm
    201  0000 ????
    202  0000 ????				      mac	sbne
    203  0000 ????				      bne	{1}
    204  0000 ????				      if	(* ^ {1}) & $FF00
    205  0000 ????				      echo	"PAGE CROSSING","WARNING ",{1}," at ",*
    206  0000 ????				      err
    207  0000 ????				      endif
    208  0000 ????				      endm
    209  0000 ????
    210  0000 ????				      mac	sbpl
    211  0000 ????				      bpl	{1}
    212  0000 ????				      if	(* ^ {1}) & $FF00
    213  0000 ????				      echo	"PAGE CROSSING","WARNING ",{1}," at ",*
    214  0000 ????				      err
    215  0000 ????				      endif
    216  0000 ????				      endm
    217  0000 ????
    218  0000 ????				      mac	sbvc
    219  0000 ????				      bvc	{1}
    220  0000 ????				      if	(* ^ {1}) & $FF00
    221  0000 ????				      echo	"PAGE CROSSING","WARNING ",{1}," at ",*
    222  0000 ????				      err
    223  0000 ????				      endif
    224  0000 ????				      endm
    225  0000 ????
    226  0000 ????				      mac	sbvs
    227  0000 ????				      bvs	{1}
    228  0000 ????				      if	(* ^ {1}) & $FF00
    229  0000 ????				      echo	"PAGE CROSSING","WARNING ",{1}," at ",*
    230  0000 ????				      err
    231  0000 ????				      endif
    232  0000 ????				      endm
    233  0000 ????
    234  0000 ????						;-------------------------------------------------------
    235  0000 ????						; DIFFERENT PAGE BRANCH CHECK
    236  0000 ????						; Original auther: Darrell Spice, Jr.
    237  0000 ????						;
    238  0000 ????						; Usage: dbeq, dbne, etc just like a normal beq, bne, etc.
    239  0000 ????						;	  A message will be output if the target of the branch
    240  0000 ????						;	  is not on a different page.
    241  0000 ????						;
    242  0000 ????				      mac	dbcc
    243  0000 ????				      bcc	{1}
    244  0000 ????				      if	((* ^ {1}) & $FF00) = 0
    245  0000 ????				      echo	"SAME PAGE","WARNING ",{1}," at ",*
    246  0000 ????				      err
    247  0000 ????				      endif
    248  0000 ????				      endm
    249  0000 ????
    250  0000 ????				      mac	dbcs
    251  0000 ????				      bcs	{1}
    252  0000 ????				      if	((* ^ {1}) & $FF00) = 0
    253  0000 ????				      echo	"SAME PAGE","WARNING ",{1}," at ",*
    254  0000 ????				      err
    255  0000 ????				      endif
    256  0000 ????				      endm
    257  0000 ????
    258  0000 ????				      mac	dbeq
    259  0000 ????				      beq	{1}
    260  0000 ????				      if	((* ^ {1}) & $FF00) = 0
    261  0000 ????				      echo	"SAME PAGE","WARNING ",{1}," at ",*
    262  0000 ????				      err
    263  0000 ????				      endif
    264  0000 ????				      endm
    265  0000 ????
    266  0000 ????				      mac	dbmi
    267  0000 ????				      bmi	{1}
    268  0000 ????				      if	((* ^ {1}) & $FF00) = 0
    269  0000 ????				      echo	"SAME PAGE","WARNING ",{1}," at ",*
    270  0000 ????				      err
    271  0000 ????				      endif
    272  0000 ????				      endm
    273  0000 ????
    274  0000 ????				      mac	dbne
    275  0000 ????				      bne	{1}
    276  0000 ????				      if	((* ^ {1}) & $FF00) = 0
    277  0000 ????				      echo	"SAME PAGE","WARNING ",{1}," at ",*
    278  0000 ????				      err
    279  0000 ????				      endif
    280  0000 ????				      endm
    281  0000 ????
    282  0000 ????				      mac	dbpl
    283  0000 ????				      bpl	{1}
    284  0000 ????				      if	((* ^ {1}) & $FF00) = 0
    285  0000 ????				      echo	"SAME PAGE","WARNING ",{1}," at ",*
    286  0000 ????				      err
    287  0000 ????				      endif
    288  0000 ????				      endm
    289  0000 ????
    290  0000 ????				      mac	dbvc
    291  0000 ????				      bvc	{1}
    292  0000 ????				      if	((* ^ {1}) & $FF00) = 0
    293  0000 ????				      echo	"SAME PAGE","WARNING ",{1}," at ",*
    294  0000 ????				      err
    295  0000 ????				      endif
    296  0000 ????				      endm
    297  0000 ????
    298  0000 ????				      mac	dbvs
    299  0000 ????				      bvs	{1}
    300  0000 ????				      if	((* ^ {1}) & $FF00) = 0
    301  0000 ????				      echo	"SAME PAGE","WARNING ",{1}," at ",*
    302  0000 ????				      err
    303  0000 ????				      endif
    304  0000 ????				      endm
    305  0000 ????
    306  0000 ????
    307  0000 ????						; EOF
------- FILE cubiks.asm
------- FILE cdfj.h LEVEL 2 PASS 2
      0  0000 ????				      include	"cdfj.h"
      1  0000 ????						;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      2  0000 ????						; CDF Bankswitching Include
      3  0000 ????						; (C) Copyright 2017 - Chris Walton, Fred Quimby, Darrell Spice Jr
      4  0000 ????						;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      5  0000 ????
      6  0000 ????						; Fetcher Constants
      7  0000 ????	       00 00	   DS0DATA    =	$00
      8  0000 ????	       00 01	   DS1DATA    =	$01
      9  0000 ????	       00 02	   DS2DATA    =	$02
     10  0000 ????	       00 03	   DS3DATA    =	$03
     11  0000 ????	       00 04	   DS4DATA    =	$04
     12  0000 ????	       00 05	   DS5DATA    =	$05
     13  0000 ????	       00 06	   DS6DATA    =	$06
     14  0000 ????	       00 07	   DS7DATA    =	$07
     15  0000 ????	       00 08	   DS8DATA    =	$08
     16  0000 ????	       00 09	   DS9DATA    =	$09
     17  0000 ????	       00 0a	   DS10DATA   =	$0A
     18  0000 ????	       00 0b	   DS11DATA   =	$0B
     19  0000 ????	       00 0c	   DS12DATA   =	$0C
     20  0000 ????	       00 0d	   DS13DATA   =	$0D
     21  0000 ????	       00 0e	   DS14DATA   =	$0E
     22  0000 ????	       00 0f	   DS15DATA   =	$0F
     23  0000 ????	       00 10	   DS16DATA   =	$10
     24  0000 ????	       00 11	   DS17DATA   =	$11
     25  0000 ????	       00 12	   DS18DATA   =	$12
     26  0000 ????	       00 13	   DS19DATA   =	$13
     27  0000 ????	       00 14	   DS20DATA   =	$14
     28  0000 ????	       00 15	   DS21DATA   =	$15
     29  0000 ????	       00 16	   DS22DATA   =	$16
     30  0000 ????	       00 17	   DS23DATA   =	$17
     31  0000 ????	       00 18	   DS24DATA   =	$18
     32  0000 ????	       00 19	   DS25DATA   =	$19
     33  0000 ????	       00 1a	   DS26DATA   =	$1A
     34  0000 ????	       00 1b	   DS27DATA   =	$1B
     35  0000 ????	       00 1c	   DS28DATA   =	$1C
     36  0000 ????	       00 1d	   DS29DATA   =	$1D
     37  0000 ????	       00 1e	   DS30DATA   =	$1E
     38  0000 ????	       00 1f	   DS31DATA   =	$1F
     39  0000 ????	       00 20	   DSCOMM     =	$20	; datastream used for DSPTR and DSWRITE
     40  0000 ????	       00 21	   DSJMP1     =	$21	; datastream used for JMP FASTJMP1
     41  0000 ????	       00 22	   DSJMP2     =	$22	; datastream used for JMP FASTJMP2
     42  0000 ????	       00 23	   AMPLITUDE  =	$23
     43  0000 ????
     44  0000 ????	       00 21	   DSJMP      =	DSJMP1	; for backwards compaitibility
     45  0000 ????
     46  0000 ????						; Mode Constants
     47  0000 ????	       00 00	   FASTON     =	$00
     48  0000 ????	       00 0f	   FASTOFF    =	$0F
     49  0000 ????	       00 00	   AUDIOSAMPLE =	$00
     50  0000 ????	       00 f0	   AUDIOMUSIC =	$F0
     51  0000 ????
     52  0000 ????						; FastJmp Address
     53  0000 ????	       00 00	   FASTJMP1   =	$0000
     54  0000 ????	       00 01	   FASTJMP2   =	$0001
     55  0000 ????
     56  0000 ????	       00 00	   FASTJMP    =	FASTJMP1	; for backwards compatibility
     57  0000 ????
     58  0000 ????						; CDF Base Address
     59  0000 ????			  -	      IFNCONST	CDF_BASE_ADDRESS
     60  0000 ????			  -CDF_BASE_ADDRESS =	$1FF0
     61  0000 ????				      ENDIF
     62  0000 ????
     63  0000 ????						; CDF Registers
     64 U1ffc ????				      SEG.U	CDF_REGISTERS
     65 U1ff0					      ORG	CDF_BASE_ADDRESS
     66 U1ff0
     67 U1ff0							; Write Registers
     68 U1ff0		       00	   DSWRITE    DS	1	; $1FF0
     69 U1ff1		       00	   DSPTR      DS	1	; $1FF1
     70 U1ff2		       00	   SETMODE    DS	1	; $1FF2
     71 U1ff3		       00	   CALLFN     DS	1	; $1FF3
     72 U1ff4		       00		      DS	1	; $1FF4
     73 U1ff5		       00	   SELECTBANK0 DS	1	; $1FF5
     74 U1ff6		       00	   SELECTBANK1 DS	1	; $1FF6
     75 U1ff7		       00	   SELECTBANK2 DS	1	; $1FF7
     76 U1ff8		       00	   SELECTBANK3 DS	1	; $1FF8
     77 U1ff9		       00	   SELECTBANK4 DS	1	; $1FF9
     78 U1ffa		       00	   SELECTBANK5 DS	1	; $1FFA
     79 U1ffb		       00	   SELECTBANK6 DS	1	; $1FFB
     80  0000 ????				      SEG
     81  0000 ????
     82  0000 ????
------- FILE cubiks.asm
     11  0000 ????
     12  0000 ????				      MAC	fetch
     13  0000 ????				      lda	#{1}
     14  0000 ????				      sta	{2}
     15  0000 ????				      ENDM		; stream, destination
     16  0000 ????
     17  0000 ????
     18  0000 ????	       00 14	   CDC	      =	20
     19  0000 ????
     20  0000 ????						; Symbols prefixed with _ are exported to 'main/defines_from_dasm_for_c.h'
     21  0000 ????						; This is done via 'awk' in the makefile.
     22  0000 ????
     23  0000 ????
     24  0000 ????						; which ARM function to run
     25  0000 ????	       00 00	   _FN_INIT   =	0	; Initialize()
     26  0000 ????	       00 01	   _FN_GAME_OS =	1	; GameOverscan()
     27  0000 ????	       00 02	   _FN_GAME_VB =	2	; GameVerticalBlank()
     28  0000 ????	       00 03	   _FN_MENU_OS =	3	; MenuOverScan()
     29  0000 ????	       00 04	   _FN_GAME_IDLE =	4	; idle loop
     30  0000 ????
     31  0000 ????
     32  0000 ????	       00 04	   _DS_PF0_LEFT =	DS4DATA
     33  0000 ????	       00 05	   _DS_PF1_LEFT =	DS5DATA
     34  0000 ????	       00 06	   _DS_PF2_LEFT =	DS6DATA
     35  0000 ????	       00 07	   _DS_PF0_RIGHT =	DS7DATA
     36  0000 ????	       00 08	   _DS_PF1_RIGHT =	DS8DATA
     37  0000 ????	       00 09	   _DS_PF2_RIGHT =	DS9DATA
     38  0000 ????
     39  0000 ????	       00 0a	   _DS_COLUPF =	DS10DATA
     40  0000 ????	       00 0d	   _DS_COLUBK =	DS13DATA
     41  0000 ????	       00 00	   _DS_COLUP0 =	DS0DATA
     42  0000 ????	       00 01	   _DS_COLUP1 =	DS1DATA
     43  0000 ????
     44  0000 ????	       00 0e	   _DS_AUDV0  =	DS14DATA
     45  0000 ????	       00 0f	   _DS_AUDC0  =	DS15DATA
     46  0000 ????	       00 10	   _DS_AUDF0  =	DS16DATA
     47  0000 ????
     48  0000 ????
     49  0000 ????	       00 0b	   _DS_GRP0a  =	DS11DATA
     50  0000 ????	       00 0c	   _DS_GRP1a  =	DS12DATA
     51  0000 ????
     52  0000 ????						; timer values
     53  0000 ????
     54  0000 ????						; NTSC...
     55  0000 ????	       00 38	   VB_TIM64T  =	56	;46; //7; //7
     56  0000 ????	       00 1b	   OS_TIM64T  =	27	; 41; //33 ;-3
     57  0000 ????
     58  0000 ????						; PAL...
     59  0000 ????						; VB_TIM64T = 76;46; //7; //7
     60  0000 ????						; OS_TIM64T = 53; 41; //33 ;-3
     61  0000 ????
     62  0000 ????
     63  0000 ????						; controls spacing in main menu
     64  0000 ????
     65  0000 ????	       00 c9	   _ARENA_SCANLINES =	201	; number of scanlines for the arena
     66  0000 ????	       00 c9	   ARENA_BUFFER_SIZE =	201	; PF buffer size for largest arena
     67  0000 ????
     68  0000 ????						;===============================================================================
     69  0000 ????						; Define custom Macros
     70  0000 ????						;----------------------------------------
     71  0000 ????						; POSITION_OBJECT is defined as a macro because it appears at the same position
     72  0000 ????						; in both banks of 6507 code.
     73  0000 ????						;
     74  0000 ????						; CHECK_ARENA_BUFFER_SIZE is used to make sure the playfield buffers are large
     75  0000 ????						; enough for the graphics.
     76  0000 ????						;===============================================================================
     77  0000 ????				      MAC	position_object
     78  0000 ????						; sets X position of any object.  X holds which object, A holds position
     79  0000 ????			   PosObject		; A holds X value
     80  0000 ????				      sec		; 2
     81  0000 ????				      sta	WSYNC	; X holds object, 0=P0, 1=P1, 2=M0, 3=M1, 4=Ball
     82  0000 ????			   DivideLoop
     83  0000 ????				      sbc	#15	; 2
     84  0000 ????				      bcs	DivideLoop	; 2  4
     85  0000 ????				      eor	#7	; 2  6
     86  0000 ????				      asl		; 2  8
     87  0000 ????				      asl		; 2 10
     88  0000 ????				      asl		; 2 12
     89  0000 ????				      asl		; 2 14
     90  0000 ????				      sta.wx	HMP0,X	; 5 19
     91  0000 ????				      sta	RESP0,X	; 4 23 <- set object position
     92  0000 ????			   SLEEP12    rts		; 6 29
     93  0000 ????				      ENDM
     94  0000 ????
     95  0000 ????
     96  0000 ????				      MAC	check_arena_buffer_size
     97  0000 ????						; trigger a compile time error if the arena buffer need to be increased
     98  0000 ????				      IF	{1} > ARENA_BUFFER_SIZE
     99  0000 ????				      echo	"Increase ARENA_BUFFER_SIZE to",[{1}]d
    100  0000 ????				      err
    101  0000 ????				      ENDIF
    102  0000 ????				      ENDM
    103  0000 ????
    104  0000 ????
    105  0000 ????						;===============================================================================
    106  0000 ????						; Define Zero Page RAM Usage
    107  0000 ????						;----------------------------------------
    108  0000 ????						;   ZP RAM variables can only be seen by the 6507 CPU
    109  0000 ????						;   Likewise C variables can only be seen by the ARM CPU
    110  0000 ????						;===============================================================================
    111  0000 ????
    112 U0085 ????				      SEG.U	VARS
    113 U0080					      ORG	$80
    114 U0080
    115 U0080		       00	   Mode       ds	1	; $00 = splash, $01 = menu, $80 = game
    116 U0081							; these values allow for easy testing of Mode:
    117 U0081							;   LDA Mode
    118 U0081							;   BMI GAME_ROUTINE
    119 U0081							;   BNE MENU_ROUTINE
    120 U0081							;   BEQ SPLASH_routine
    121 U0081		       00	   LoopCounter ds	1
    122 U0082		       00	   TimeLeftOS ds	1
    123 U0083		       00	   TimeLeftVB ds	1
    124 U0084		       00	   Temp       ds	1
    125 U0085
 ---- $79 bytes of RAM left (space reserved for 2 byte stack)
    126 U0085					      echo	"----",($00FE - *) , "bytes of RAM left (space reserved for 2 byte stack)"
    127 U0085
    128 U0085
    129 U0085
    130 U0085							;===============================================================================
    131 U0085							; Define Start of Cartridge
    132 U0085							;----------------------------------------
    133 U0085							;   CDFJ cartridges must start with the Harmony/Melody driver.  The driver is
    134 U0085							;   the ARM code that emulates the CDFJ coprocessor.
    135 U0085							;===============================================================================
    136 U0085
    137  8000 ????				      SEG	CODE
    138  0000					      ORG	0
    139  0000
    140  0000					      incbin	"cdfdriver20190317.bin"
    141  0800
    142  0800
    143  0800
    144  0800							;===============================================================================
    145  0800							; ARM user code
    146  0800							; Banks 0 thru 4
    147  0800							;----------------------------------------
    148  0800							;   The ARM code starts at $0800 and grows into bank 0+
    149  0800							;===============================================================================
    150  0800
    151  0800					      ORG	$0800
    152  0800
    153  0800							; include the custom ARM code.
    154  0800
    155  0800					      incbin	"main/bin/armcode.bin"
    156  3da0
    157  3da0
    158  3da0
    159  3da0
    160  3da0							;===============================================================================
    161  3da0							; ARM Indirect Data
    162  3da0							;----------------------------------------
    163  3da0							;   Data that the C code indirectly accesses can be stored immediately after the
    164  3da0							;   custom ARM code.
    165  3da0							;===============================================================================
    166  3da0
 ---- $3260 bytes of ARM and Moveable Data space left
    167  3da0					      echo	"----",($7000 - *) , "bytes of ARM and Moveable Data space left"
    168  3da0
    169  3da0
    170  3da0
    171  3da0							;===============================================================================
    172  3da0							; ARM Direct Data
    173  3da0							;----------------------------------------
    174  3da0							;   I find it easier, and more space efficient, to store some of the data the
    175  3da0							;   C code needs to access in the 6507 code instead of the C code.  Because the
    176  3da0							;   build process is:
    177  3da0							;
    178  3da0							;	 1) assemble 6507 code to create defines_from_dasm_for_c.h
    179  3da0							;	 2) compile C code to create ARM routines
    180  3da0							;	 3) assemble 6507 to create final ROM
    181  3da0							;
    182  3da0							;   the ARM code could change size between steps 1 and 3, which would shift data
    183  3da0							;   that immediately comes after it. So the data that C directly accesses needs
    184  3da0							;   to be after an ORG to prevent it from moving.
    185  3da0							;
    186  3da0							;   The _IMAGE_GRAPHICS, _IMAGE_COLORS, etc data tables are directly access by
    187  3da0							;   the C code so must be in the Direct Data area. The data they point to is
    188  3da0							;   indirectly accessed by the C code, so they can go in the Indirect Data area.
    189  3da0							;   Note the labels for the tables are prefixed by _ so they'll end up in the
    190  3da0							;   defines_from_dasm_for_c.h file, while the labels for the data the tables
    191  3da0							;   point to are not prefixed by _
    192  3da0							;===============================================================================
    193  3da0							;	  ORG $5F80
    194  3da0							;	  ORG $5FFF
    195  3da0							;_ARENA_INCREMENTS:
    196  3da0							;	  .byte 255 ; * Arena1_Height / _ARENA_SCANLINES
    197  3da0							;	  .byte 255 ;* Arena2_Height / _ARENA_SCANLINES
    198  3da0							;	  .byte 255 ;* Arena3_Height / _ARENA_SCANLINES
    199  3da0							;	  .byte 255 ;* Arena4_Height / _ARENA_SCANLINES
    200  3da0
    201  3da0
    202  3da0
    203  3da0							; value used in this echo depends upon how many banks are used for 6507 code
    204  3da0							;   $5000 if using banks 4, 5 & 6
    205  3da0							;   $6000 if using banks 5 & 6
    206  3da0							;   $7000 if using just bank 6
    207  3da0							;    echo "----",[$6000 - *] , "bytes of ARM Direct Data left"
    208  3da0
    209  3da0							;===============================================================================
    210  3da0							; Bank 5 - 6507 code
    211  3da0							;----------------------------------------
    212  3da0							;   I normally allocate banks 0-5 for ARM code, and just use bank 6 for 6507
    213  3da0							;   code, but in order to show an example of CDFJ bankswitching I am using bank
    214  3da0							;   5 for the splash screen and menu routines.
    215  3da0							;===============================================================================
    216  3da0
    217  3da0							;	  ORG $6000
    218  3da0							;	  RORG $F000
    219  3da0
    220  3da0							; this and SplashMenuVB in bank 6 are used to switch between the banks
    221  3da0							;SplashMenuOS:
    222  3da0							;	  sta SELECTBANK6	  ; switch to bank 6, then jmp SplashMenuOS_Code
    223  3da0							;	  jmp SplashMenuVB_Code
    224  3da0
    225  3da0							;	  POSITION_OBJECT	  ; this must occupy same address in both banks
    226  3da0
    227  3da0
    228  3da0
    229  3da0							;===============================================================================
    230  3da0							; Two Color Graphic routine
    231  3da0							;-------------------------------------------------------------------------------
    232  3da0							; this works by using a "negative" image when drawing the sprites.
    233  3da0							; The sprites are colored black while the background is the color
    234  3da0							; that shows up as though it were the sprites.  The 2nd color is
    235  3da0							; achieved by using the playfield and/or ball.
    236  3da0							;
    237  3da0							; The missiles (also black) and setting the screen & playfield to BLACK
    238  3da0							; are used to hide the screen and playfield beyond the 48 pixel image.
    239  3da0							;===============================================================================
    240  3da0							;ShowTwoColorGraphic:
    241  3da0
    242  3da0
    243  3da0							;SplashMenuVB_Code:	  ; entry point from Bank 6
    244  3da0							;	  lda Mode	  ; check which screen to show
    245  3da0							;	  bne MenuVB	  ; Mode 1 = Menu
    246  3da0							;	  jmp SplashVB	  ; Mode 0 = Splash
    247  3da0
    248  3da0							;MenuVB:
    249  3da0							; players are already in position, just need to set size/copies & color
    250  3da0							;	  ldy #%11111111
    251  3da0							;	  sty GRP0
    252  3da0							;	  sty GRP1
    253  3da0							;	  ldy #%00100000  ; Ball Size = 4
    254  3da0							;	  sty CTRLPF	  ; repeat playfield, ball width = 4
    255  3da0							;	  ldy #_BLACK
    256  3da0							;	  sty COLUP0
    257  3da0							;	  sty COLUP1
    258  3da0							;	  ldy #%00010000;11
    259  3da0							;	  sty ENAM0	      ; missile on
    260  3da0							;	  sty ENAM1	      ; missile on
    261  3da0							;	  sty ENABL	      ; ball on
    262  3da0							;	  sty NUSIZ0	      ; three copies close, missile x8
    263  3da0							;	  sty NUSIZ1	      ; three copies close, missile x8
    264  3da0							;	  sty VDELP0	      ; vertical delay on
    265  3da0							;	  sty VDELP1	      ; vertical delay on
    266  3da0
    267  3da0
    268  3da0							;	  ldx #0
    269  3da0							;	  stx COLUPF
    270  3da0							;MenuVBwait:
    271  3da0							;	  sta WSYNC
    272  3da0							;	  bit TIMINT
    273  3da0							;	  bpl MenuVBwait
    274  3da0							;	  stx VBLANK		  ; video output on
    275  3da0
    276  3da0							;MenuKernel:
    277  3da0
    278  3da0							;MenuDone:
    279  3da0							;	  sta WSYNC
    280  3da0							;	  stx ENAM0    ; X=0 after ShowTwoColorGraphic
    281  3da0							;	  stx ENAM1
    282  3da0							;	  stx ENABL
    283  3da0
    284  3da0
    285  3da0							;ShowSpiceWareLogo:
    286  3da0							;SSWL1:
    287  3da0							;SSWLskip1:			  ;   15 from branch just before SSWL1
    288  3da0							;EndShowSpiceWareLogo:
    289  3da0
    290  3da0							;MenuOS:
    291  3da0							;	  ldy #_FN_MENU_OS    ; going to run function MenuOverScan()
    292  3da0							;	  jmp SplashMenuOS
    293  3da0
    294  3da0
    295  3da0							;SplashVB:
    296  3da0							;SplashVBwait:
    297  3da0							;SplashKernel:
    298  3da0							;SplashOS:
    299  3da0							;	  ldy #_FN_SPLASH_OS	  ; going to run function SplashOverScan()
    300  3da0							;	  jmp SplashMenuOS
    301  3da0
    302  3da0
    303  3da0							;    echo ($FFE9-*), "(6507) bytes left in bank 6"
    304  3da0
    305  3da0							;include "48x128.asm"
    306  3da0
    307  3da0
    308  3da0							;    echo ($FFE9-*), "AFTER 48x128 include, (6507) bytes left in bank 6"
    309  3da0
    310  3da0							;	  ORG $6FEA
    311  3da0							;	  RORG $FFEA
    312  3da0							;B5init:
    313  3da0							;	  sta SELECTBANK6
    314  3da0							;	  jmp B5init	  ; should never get here, but just in case
    315  3da0							;	  ds 12, 0	  ; reserve space for CDFJ registers
    316  3da0							;	  .WORD B5init	  ; while CDFJ will only power up in bank 5, an accidental
    317  3da0							;	  .WORD B5init	  ; BRK instruction could occur, so gracefully handle it
    318  3da0
    319  3da0
    320  3da0
    321  3da0							;===============================================================================
    322  3da0							; Bank 6 - 6507 code
    323  3da0							;----------------------------------------
    324  3da0							;   CDFJ will always start in bank 6 because banks 0-5 could contain ARM code
    325  3da0							;===============================================================================
    326  3da0
    327  7000					      ORG	$7000
    328  7000					      RORG	$F000
    329  7000
    330  7000
    331  7000
    332  7000							; this and SplashMenuOS in bank 5 are used to switch between the banks
    333  7000				   SplashMenuVB
    334  7000		       8d fa 1f 	      sta	SELECTBANK5	; switch to bank 5, then jmp SplashMenuVB_Code
    335  7003		       4c b1 f0 	      jmp	SplashMenuOS_Code
    336  7006
      0  7006					      POSITION_OBJECT		; this must occupy same address in both banks
      1  7006
      2  7006				   PosObject
      3  7006		       38		      sec
      4  7007		       85 02		      sta	WSYNC
      5  7009				   DivideLoop
      6  7009		       e9 0f		      sbc	#15
      7  700b		       b0 fc		      bcs	DivideLoop
      8  700d		       49 07		      eor	#7
      9  700f		       0a		      asl
     10  7010		       0a		      asl
     11  7011		       0a		      asl
     12  7012		       0a		      asl
     13  7013		       9d 20 00 	      sta.wx	HMP0,X
     14  7016		       95 10		      sta	RESP0,X
     15  7018		       60	   SLEEP12    rts
    338  7019
    339  7019							; CallArmCode is only called from bank 6. If we needed to also call it
    340  7019							; from bank 5 then we would set up a macro like POSITION_OBJECT
    341  7019
    342  7019				   CallArmCode
    343  7019
    344  7019							; Y = function to run
    345  7019							;   _FN_GAME_OS     game overscan
    346  7019
    347  7019
    348  7019		       a2 00		      ldx	#<_DS_TO_ARM
    349  701b		       8e f1 1f 	      stx	DSPTR
    350  701e		       a2 00		      ldx	#>_DS_TO_ARM	; NOTE: if _DS_TO_ARM = 0 we can leave out this LDX
    351  7020		       8e f1 1f 	      stx	DSPTR
    352  7023		       8c f0 1f 	      sty	DSWRITE	; save in _RUN_FUNC, Y holds which function to call
    353  7026		       ae 80 02 	      ldx	SWCHA	; read state of both joysticks
    354  7029		       8e f0 1f 	      stx	DSWRITE	; save in _SWCHA
    355  702c		       ae 82 02 	      ldx	SWCHB	; read state of console switches
    356  702f		       8e f0 1f 	      stx	DSWRITE	; save in _SWCHB
    357  7032		       a6 0c		      ldx	INPT4	; read state of left joystick firebutton
    358  7034		       8e f0 1f 	      stx	DSWRITE	; save in _INPT4
    359  7037		       a6 0d		      ldx	INPT5	; read state of right joystick firebutton
    360  7039		       8e f0 1f 	      stx	DSWRITE	; save in _INPT5
    361  703c		       a6 83		      ldx	TimeLeftVB	; Time remaining in VB (only tracked for game screen)
    362  703e		       8e f0 1f 	      stx	DSWRITE	; save in _VB_TIME
    363  7041		       a6 82		      ldx	TimeLeftOS	; Time remaining in OS (only tracked for game screen)
    364  7043		       8e f0 1f 	      stx	DSWRITE	; save in _OS_TIME
    365  7046
    366  7046		       a2 ff		      ldx	#$FF	; FF = Run ARM code w/out digital audio interrupts
    367  7048		       8e f3 1f 	      stx	CALLFN	; runs main() in the C code (6507 is $EA-locked)
    368  704b
      0  704b					      FETCH	DSCOMM, Mode	; get the current game mode
      1  704b		       a9 20		      lda	#DSCOMM
      2  704d		       85 80		      sta	Mode
    370  704f		       60		      rts
    371  7050
    372  7050
    373  7050				   safeTimerWait
    374  7050
    375  7050							; Now we wait for expiry of the timer.
    376  7050							; The code records the available time for display. This is the INTIM value at the start
    377  7050							; of the wait. This INTIM read clears the TIMINT flag, so we go through some convolutions
    378  7050							; to make it all work.
    379  7050
    380  7050
    381  7050		       a2 00		      ldx	#0
    382  7052		       2c 85 02 	      bit	TIMINT
    383  7055		       30 0f		      bmi	.zeroTime	; already overtime!
    384  7057		       ad 84 02 	      lda	INTIM
    385  705a		       f0 0a		      beq	.zeroTime	; also time expired
    386  705c		       30 08		      bmi	.zeroTime	; must have been just overtime and now counting down
    387  705e		       aa		      tax
    388  705f		       85 02	   .xOSwait   sta	WSYNC
    389  7061		       2c 85 02 	      bit	TIMINT	; wait for the timer
    390  7064		       10 f9		      bpl	.xOSwait
    391  7066
    392  7066		       86 82	   .zeroTime  stx	TimeLeftOS	; x holds the "how much time left"
    393  7068		       60		      rts
    394  7069
    395  7069
    396  7069
    397  7069				   InitSystem
    398  7069							; Console Detection Routine
    399  7069							;
    400  7069							; normally we'd use CLEAN_START, but to detect if console is 2600 or 7800
    401  7069							; we need to take a look at the ZP RAM values in $80, $D0, and $D1 before
    402  7069							; zeroing out RAM
    403  7069							;
    404  7069							;   if $D0 contains $2C and $D1 contains $A9 then
    405  7069							;	 system = 7800		 // game was loaded from Harmony menu on a 7800
    406  7069							;   else if both contain $00 then
    407  7069							;	 system = ZP RAM $80	 // game was flashed to Harmony/Melody so CDFJ
    408  7069							;				 // driver checked $D0 and $D1 for us and saved
    409  7069							;				 // results in $80
    410  7069							;   else
    411  7069							;	 system = 2600		 // game was loaded from Harmony menu on a 2600
    412  7069
    413  7069		       78		      sei
    414  706a		       d8		      cld
    415  706b
    416  706b		       a0 00		      ldy	#0	; assume system = 2600
    417  706d		       a6 d0		      ldx	$d0
    418  706f		       f0 0d		      beq	.confirmFlashed	; if $00 then game might be flashed on Harmony/Melody
    419  7071		       e0 2e		      cpx	#$2c+2
    420  7073		       d0 0f		      bne	.is2600	; if not $2C then loaded via Harmony Menu on 2600
    421  7075		       a6 d1		      ldx	$d1
    422  7077		       e0 a9		      cpx	#$a9
    423  7079		       d0 09		      bne	.is2600
    424  707b		       88		      dey		; 7800: y=$FF
    425  707c		       d0 06		      bne	.done	; this will always branch
    426  707e
    427  707e				   .confirmFlashed
    428  707e		       a6 d1		      ldx	$d1
    429  7080		       d0 02		      bne	.is2600	; if not $00 then loaded via Harmony Menu on 2600
    430  7082		       a4 80		      ldy	$80	; else get the value saved by the CDFJ driver
    431  7084
    432  7084				   .is2600		; 2600: y == 0
    433  7084				   .done		; 7800: y != 0
    434  7084							; end of console detection routine, y contains results
    435  7084
    436  7084		       a2 00		      ldx	#0
    437  7086		       8a		      txa
    438  7087		       ca	   CLEAR_ZP   dex
    439  7088		       9a		      txs
    440  7089		       48		      pha
    441  708a		       d0 fb		      bne	CLEAR_ZP	; SP=$FF, X = A = 0
    442  708c
    443  708c							; Fast Fetch mode must be turned on so we can read the datastreams
    444  708c							; Note: Fast Fetch mode overrides LDA #, so need to use LDX # or
    445  708c							;	 LDY # if not reading a CDFJ register
    446  708c		       a2 00		      ldx	#FASTON
    447  708e		       8e f2 1f 	      stx	SETMODE
    448  7091
    449  7091		       a2 00		      ldx	#<_DS_TO_ARM
    450  7093		       8e f1 1f 	      stx	DSPTR
    451  7096		       a2 00		      ldx	#>_DS_TO_ARM	; NOTE: if _DS_TO_ARM = 0 we can leave out this LDX
    452  7098		       8e f1 1f 	      stx	DSPTR
    453  709b		       a2 00		      ldx	#_FN_INIT	; going to run function Initialize()
    454  709d		       8e f0 1f 	      stx	DSWRITE	; save in _RUN_FUNC
    455  70a0		       8c f0 1f 	      sty	DSWRITE	; save 2600/7800 value in _SWCHA
    456  70a3		       8c f0 1f 	      sty	DSWRITE	; save 2600/7800 value in _SWCHB
    457  70a6		       8c f0 1f 	      sty	DSWRITE	; save 2600/7800 value in _INPT4
    458  70a9		       8c f0 1f 	      sty	DSWRITE	; save 2600/7800 value in _INPT5
    459  70ac		       a2 ff		      ldx	#$FF	; FF = Run ARM code w/out digital audio interrupts
    460  70ae		       8e f3 1f 	      stx	CALLFN	; runs main() in the C code
    461  70b1
    462  70b1							;	  ldy #_FN_SPLASH_OS	  ; going to run function SplashOverScan()
    463  70b1							;	  bne SplashMenuOS_Code
    464  70b1
    465  70b1
    466  70b1
    467  70b1				   OverScan
    468  70b1
    469  70b1							;    ldx #$C4
    470  70b1							;    stx COLUBK
    471  70b1
    472  70b1
    473  70b1							;	  ldy #_FN_GAME_OS	  ; going to run function GameOverscan()
    474  70b1				   SplashMenuOS_Code		; entry point from bank 5 & InitSystem with Y already set
    475  70b1		       85 02		      sta	WSYNC
    476  70b3		       a2 02		      ldx	#2
    477  70b5		       86 01		      stx	VBLANK	; video output off
    478  70b7		       a2 1b		      ldx	#OS_TIM64T
    479  70b9		       8e 96 02 	      stx	TIM64T	; set timer for OS
    480  70bc
    481  70bc
    482  70bc		       a0 01		      ldy	#_FN_GAME_OS
    483  70be
    484  70be		       20 19 f0    Again2     jsr	CallArmCode	; draws the chessboard!
    485  70c1		       ae 85 02 	      ldx	TIMINT
    486  70c4		       30 0c		      bmi	.ag2
    487  70c6		       a0 04		      ldy	#_FN_GAME_IDLE
    488  70c8		       ae 84 02 	      ldx	INTIM
    489  70cb		       e0 14		      cpx	#CDC
    490  70cd		       b0 ef		      bcs	Again2
    491  70cf
    492  70cf
    493  70cf							;		  ldx #$C2
    494  70cf							;		  stx COLUBK
    495  70cf
    496  70cf		       20 50 f0 	      jsr	safeTimerWait
    497  70d2
    498  70d2				   .ag2
    499  70d2
    500  70d2
    501  70d2
    502  70d2				   VerticalSync
    503  70d2		       a0 02		      ldy	#2
    504  70d4							;    ldx #$46
    505  70d4							;    stx COLUBK ;boo
    506  70d4		       a2 38		      ldx	#VB_TIM64T
    507  70d6		       84 02		      sty	WSYNC
    508  70d8
    509  70d8
    510  70d8							; --- start scanline 1 of Vertical Sync ---
    511  70d8		       84 00		      sty	VSYNC	; 3  3  turn on Vertical Sync signal
    512  70da		       8e 96 02 	      stx	TIM64T	; 4  7
    513  70dd		       84 02		      sty	WSYNC	; 3 10/0
    514  70df							; --- start scanline 2 of Vertical Sync ---
    515  70df							; use otherwise wasted time to zero out some TIA registers
    516  70df		       a2 00		      ldx	#0	; 2  2
    517  70e1		       86 1b		      stx	GRP0	; 3  5
    518  70e3		       86 1c		      stx	GRP1	; 3  8
    519  70e5							;stx VDELP0	      ; 3 11
    520  70e5							;stx VDELP1	      ; 3 14
    521  70e5		       86 0d		      stx	PF0	; 3 17
    522  70e7		       86 0e		      stx	PF1	; 3 20
    523  70e9		       86 0f		      stx	PF2	; 3 23
    524  70eb		       86 0a		      stx	CTRLPF	; 3 26
    525  70ed		       86 02		      stx	WSYNC	; 3 29/0
    526  70ef							; --- start scanline 3 of Vertical Sync ---
    527  70ef							; use otherwise wasted time to figure out
    528  70ef							; which ARM Vertical Blank routine to run
    529  70ef							;	  lda Mode	      ; 3  3 $00 = splash, $01 = menu, $80 = game
    530  70ef							;	  bmi vbgame	      ; 2  5  3  6 if taken
    531  70ef							;	  beq vbsplash	      ; 2  7	 |  3  8 if taken
    532  70ef							;	  ldy #_FN_MENU_VB    ; 2  9	 |     |  run function MenuVerticalBlank()
    533  70ef							;	  .byte $0c	      ; 4 13	 |     |  NOP ABSOLUTE, skips over ldy #_FN_SPLASH_VB
    534  70ef							;vbsplash:		      ;    |	 |     |
    535  70ef							;	  ldy #_FN_SPLASH_VB  ;    |	 |  2 10  run function SplashVerticalBlank()
    536  70ef							;	  .byte $0c	      ; 4 17	 |  4 14  NOP ABSOLUTE, skips over ldy #_FN_GAME_VB
    537  70ef							;vbgame:		      ;    |	 |     |
    538  70ef							;	  ldy #_FN_GAME_VB    ;    |  2  8     |  run function GameVerticalBlank()
    539  70ef							;   17     8	 14  17 cycles worse case scenerio
    540  70ef		       86 02		      stx	WSYNC	; end of VerticalSync scanline 3
    541  70f1		       86 00		      stx	VSYNC	; turn off Vertical Sync signal
    542  70f3							;	  jsr CallArmCode
    543  70f3
    544  70f3					      IF	1
    545  70f3							; ARM VB routines send back the initial positions of the 5 objects
    546  70f3							;vbSetInitialX:
    547  70f3							;	  lda #DSCOMM	      ; will get _BALL_X,  _M1_X,  _M0_X,  _P1_X,  and _P0_X
    548  70f3
    549  70f3		       a9 20		      lda	#DSCOMM	; discard _BALL_X
    550  70f5		       a9 20		      lda	#DSCOMM	; and _M1_X
    551  70f7		       a9 20		      lda	#DSCOMM	; and _M0_X
    552  70f9
    553  70f9		       a2 01		      ldx	#1
    554  70fb		       a9 20		      lda	#DSCOMM	; = _P1_X
    555  70fd		       20 06 f0 	      jsr	PosObject
    556  7100
    557  7100		       ca		      dex
    558  7101		       a9 20		      lda	#DSCOMM	; = _P0_X
    559  7103		       20 06 f0 	      jsr	PosObject
    560  7106
    561  7106							;	  jsr PosObject
    562  7106							;	  inx
    563  7106							;	  lda #DSCOMM	      ; will get _BALL_X,  _M1_X,  _M0_X,  _P1_X,  and _P0_X
    564  7106							;	  jsr PosObject
    565  7106							;	  dex
    566  7106							;	  bpl vbSetInitialX
    567  7106		       85 02		      sta	WSYNC
    568  7108		       85 2a		      sta	HMOVE
    569  710a
    570  710a
    571  710a		       a9 20		      lda	#DSCOMM	; ARENA COLOR
    572  710c		       85 09		      sta	COLUBK
    573  710e
    574  710e		       a9 0e		      lda	#_DS_AUDV0
    575  7110		       85 19		      sta	AUDV0
    576  7112		       a9 0f		      lda	#_DS_AUDC0
    577  7114		       85 15		      sta	AUDC0
    578  7116		       a9 10		      lda	#_DS_AUDF0
    579  7118		       85 17		      sta	AUDF0
    580  711a
    581  711a		       a9 0e		      lda	#_DS_AUDV0
    582  711c		       85 1a		      sta	AUDV1
    583  711e		       a9 0f		      lda	#_DS_AUDC0
    584  7120		       85 16		      sta	AUDC1
    585  7122		       a9 10		      lda	#_DS_AUDF0
    586  7124		       85 18		      sta	AUDF1
    587  7126
    588  7126							; figure out which 6507 Vertical Blank routine to run
    589  7126							;	 lda Mode	     ; $00 = splash, $01 = menu, $80 = game
    590  7126							;	 bmi GameVB
    591  7126							;	 jmp SplashMenuVB
    592  7126
    593  7126				   GameVB
    594  7126					      ENDIF
    595  7126
    596  7126
    597  7126		       a0 02		      ldy	#_FN_GAME_VB
    598  7128
    599  7128							;SLEEP 20
    600  7128
    601  7128		       20 19 f0    Again1     jsr	CallArmCode	; draws OBJECTS!
    602  712b
    603  712b							;SLEEP 2
    604  712b
    605  712b		       a0 04		      ldy	#_FN_GAME_IDLE
    606  712d
    607  712d		       ae 85 02    skipss2    ldx	TIMINT
    608  7130		       30 fb		      bmi	skipss2
    609  7132		       ae 84 02 	      ldx	INTIM
    610  7135		       e0 14		      cpx	#CDC
    611  7137		       b0 ef		      bcs	Again1
    612  7139
    613  7139
    614  7139
    615  7139		       20 50 f0 	      jsr	safeTimerWait
    616  713c
    617  713c
    618  713c				   skipss
    619  713c		       a2 00		      ldx	#0
    620  713e		       86 01		      stx	VBLANK	; video output on
    621  7140							;		     stx PF0
    622  7140
    623  7140
    624  7140							;		      sta WSYNC
    625  7140							;		      sta WSYNC
    626  7140		       a2 00		      ldx	#%00000000
    627  7142		       86 0a		      stx	CTRLPF
    628  7144
    629  7144
    630  7144							;		      sta WSYNC
    631  7144
    632  7144							;		       jmp FASTJMP1
    633  7144
    634  7144
    635  7144
    636  7144				   _NORMAL_KERNEL
    637  7144
    638  7144
    639  7144							; This is the entire display
    640  7144
    641  7144							;@3
    642  7144
    643  7144
    644  7144		       a9 0d		      lda	#_DS_COLUBK
    645  7146		       85 02		      sta	WSYNC
    646  7148		       85 09		      sta	COLUBK
    647  714a
    648  714a		       a9 0a		      lda	#_DS_COLUPF
    649  714c		       85 08		      sta	COLUPF
    650  714e
    651  714e		       a9 04		      lda	#_DS_PF0_LEFT
    652  7150		       85 0d		      sta	PF0	; 5
    653  7152
    654  7152		       a9 0b		      lda	#_DS_GRP0a
    655  7154		       85 1b		      sta	GRP0	; 5
    656  7156
    657  7156		       a9 05		      lda	#_DS_PF1_LEFT
    658  7158		       85 0e		      sta	PF1	; 5
    659  715a
    660  715a		       a9 0c		      lda	#_DS_GRP1a
    661  715c		       85 1c		      sta	GRP1	; 5
    662  715e
    663  715e
    664  715e
    665  715e		       a9 06		      lda	#_DS_PF2_LEFT
    666  7160		       85 0f		      sta	PF2	; 5
    667  7162
    668  7162
      0  7162					      SLEEP	5
      1  7162				   .CYCLES    SET	5
      2  7162
      3  7162				  -	      IF	.CYCLES < 2
      4  7162				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  7162				  -	      ERR
      6  7162					      ENDIF
      7  7162
      8  7162					      IF	.CYCLES & 1
      9  7162					      IFNCONST	NO_ILLEGAL_OPCODES
     10  7162		       04 00		      nop	0
     11  7164				  -	      ELSE
     12  7164				  -	      bit	VSYNC
     13  7164					      ENDIF
     14  7164				   .CYCLES    SET	.CYCLES - 3
     15  7164					      ENDIF
     16  7164
     17  7164					      REPEAT	.CYCLES / 2
     18  7164		       ea		      nop
     19  7165					      REPEND
    670  7165
    671  7165		       a9 07		      lda	#_DS_PF0_RIGHT
    672  7167		       85 0d		      sta	PF0
    673  7169		       a9 08		      lda	#_DS_PF1_RIGHT
    674  716b		       85 0e		      sta	PF1	; 5
    675  716d		       a9 09		      lda	#_DS_PF2_RIGHT	; 2
    676  716f		       85 0f		      sta	PF2	; 3
    677  7171
    678  7171
      0  7171					      SLEEP	5
      1  7171				   .CYCLES    SET	5
      2  7171
      3  7171				  -	      IF	.CYCLES < 2
      4  7171				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  7171				  -	      ERR
      6  7171					      ENDIF
      7  7171
      8  7171					      IF	.CYCLES & 1
      9  7171					      IFNCONST	NO_ILLEGAL_OPCODES
     10  7171		       04 00		      nop	0
     11  7173				  -	      ELSE
     12  7173				  -	      bit	VSYNC
     13  7173					      ENDIF
     14  7173				   .CYCLES    SET	.CYCLES - 3
     15  7173					      ENDIF
     16  7173
     17  7173					      REPEAT	.CYCLES / 2
     18  7173		       ea		      nop
     19  7174					      REPEND
    680  7174		       a9 00		      lda	#_DS_COLUP0
    681  7176		       85 06		      sta	COLUP0	; 3 @8
    682  7178		       a9 01		      lda	#_DS_COLUP1
    683  717a		       85 07		      sta	COLUP1
    684  717c
    685  717c
    686  717c		       4c 00 00 	      jmp	FASTJMP1	; 3
    687  717f
    688  717f							;@3--> start of line again :)
    689  717f
    690  717f
    691  717f		       a2 00	   _EXIT_KERNEL ldx	#0
    692  7181		       86 1b		      stx	GRP0
    693  7183		       86 1c		      stx	GRP1
    694  7185		       86 0d		      stx	PF0
    695  7187		       86 0e		      stx	PF1
    696  7189		       86 0f		      stx	PF2
    697  718b		       4c b1 f0 	      jmp	OverScan
    698  718e
    699  718e
 $f18e
    700  718e					      echo	*
 $e5e (6507) bytes left in bank 7
    701  718e					      echo	($FFEC-*), "(6507) bytes left in bank 7"
    702  718e
    703  7fed					      ORG	$7FED
    704  7fed					      RORG	$FFED
    705  7fed		       4c 69 f0 	      jmp	InitSystem
    706  7ff0		       00 00 00 00*	      ds	12, 0	; reserve space for CDFJ registers
    707  7ffc		       69 f0		      .WORD.w	InitSystem
    708  7ffe		       69 f0		      .WORD.w	InitSystem
    709  8000
    710  8000							;===============================================================================
    711  8000							; Display Data
    712  8000							;----------------------------------------
    713  8000							;   4K of RAM shared between the 6507 and ARM.
    714  8000							;
    715  8000							;   NOTE: anything prefixed with _ ends up in main/defines_from_dasm_for_c.h
    716  8000							;	   so that the C code will have the same values as the 6507 code
    717  8000							;===============================================================================
    718  8000
    719 U0fcc ????				      SEG.U	DISPLAYDATA
    720 U0000					      ORG	$0000
    721 U0000
    722 U0000				   _DS_TO_ARM
    723 U0000		       00	   _RUN_FUNC  ds	1	; function to run
    724 U0001		       00	   _SWCHA     ds	1	; joystick directions to ARM code
    725 U0002		       00	   _SWCHB     ds	1	; console switches to ARM code
    726 U0003		       00	   _INPT4     ds	1	; left firebutton state to ARM code
    727 U0004		       00	   _INPT5     ds	1	; right firebutton state to ARM code
    728 U0005		       00	   _VB_TIME   ds	1	; VB Time Remaining
    729 U0006		       00	   _OS_TIME   ds	1	; OS Time Remaining
    730 U0007
    731 U0007				   _DS_FROM_ARM
    732 U0007		       00	   _MODE      ds	1	; $00 = splash, $01 = menu, $80 = game
    733 U0008		       00	   _BALL_X    ds	1	; position of ball
    734 U0009		       00	   _M1_X      ds	1	; position of missile 1
    735 U000a		       00	   _M0_X      ds	1	; position of missile 0
    736 U000b		       00	   _P1_X      ds	1	; position of player 1
    737 U000c		       00	   _P0_X      ds	1	; position of player 0
    738 U000d		       00	   _ARENA_COLOR ds	1
    739 U000e
    740 U000e							;----------------------------------------
    741 U000e							; To save space in RAM we can share the space used by the datastream buffers
    742 U000e							; for the Splash, Menu, and Game screens.
    743 U000e							;----------------------------------------
    744 U0010		       00 00		      align	4	; using myMemsetInt to zero out RAM is faster than
    745 U0010							; myMemset, but it requires the starting address to be
    746 U0010							; 4 byte aligned
    747 U0010
    748 U0010
    749 U0010							;_BOARD	      ds 24*40
    750 U0010							;_UNCOVER	      ds 24*40/8+2		  ; +2 for word-align speed in clearing (C)
    751 U0010
    752 U0010					      align	4
    753 U0010
    754 U0010		       00 00 00 00*_BUF_JUMP1 ds	_ARENA_SCANLINES * 2	; long-word align!!
    755 U01a2		       00 00	   _BUF_JUMP1_EXIT ds	2
    756 U01a4
    757 U01a4							; DO NOT CHANGE ORDER
    758 U01a4							;{ clear in main.c assumes one block to clear
    759 U01a4
    760 U01a4							;------------------------------------------------------------------------------
    761 U01a4
    762 U01a4		       01 a4	   _BUFFERS   =	*
    763 U01a4
    764 U01a4				   BUFN       SET	0
    765 U01a4					      MAC	defbuf
    766 U01a4				   _BUF_{1}   ds	ARENA_BUFFER_SIZE
    767 U01a4				   BUFN       SET	BUFN + 1
    768 U01a4					      ENDM		;name
    769 U01a4
      0 U01a4					      DEFBUF	COLUP0
      1 U01a4		       00 00 00 00*_BUF_COLUP0 ds	ARENA_BUFFER_SIZE
      2 U01a4				   BUFN       SET	BUFN + 1
      0 U026d					      DEFBUF	COLUP1
      1 U026d		       00 00 00 00*_BUF_COLUP1 ds	ARENA_BUFFER_SIZE
      2 U026d				   BUFN       SET	BUFN + 1
      0 U0336					      DEFBUF	COLUPF
      1 U0336		       00 00 00 00*_BUF_COLUPF ds	ARENA_BUFFER_SIZE
      2 U0336				   BUFN       SET	BUFN + 1
      0 U03ff					      DEFBUF	COLUBK
      1 U03ff		       00 00 00 00*_BUF_COLUBK ds	ARENA_BUFFER_SIZE
      2 U03ff				   BUFN       SET	BUFN + 1
      0 U04c8					      DEFBUF	A_PF0_LEFT
      1 U04c8		       00 00 00 00*_BUF_A_PF0_LEFT ds	ARENA_BUFFER_SIZE
      2 U04c8				   BUFN       SET	BUFN + 1
      0 U0591					      DEFBUF	A_PF1_LEFT
      1 U0591		       00 00 00 00*_BUF_A_PF1_LEFT ds	ARENA_BUFFER_SIZE
      2 U0591				   BUFN       SET	BUFN + 1
      0 U065a					      DEFBUF	A_PF2_LEFT
      1 U065a		       00 00 00 00*_BUF_A_PF2_LEFT ds	ARENA_BUFFER_SIZE
      2 U065a				   BUFN       SET	BUFN + 1
      0 U0723					      DEFBUF	A_PF0_RIGHT
      1 U0723		       00 00 00 00*_BUF_A_PF0_RIGHT ds	ARENA_BUFFER_SIZE
      2 U0723				   BUFN       SET	BUFN + 1
      0 U07ec					      DEFBUF	A_PF1_RIGHT
      1 U07ec		       00 00 00 00*_BUF_A_PF1_RIGHT ds	ARENA_BUFFER_SIZE
      2 U07ec				   BUFN       SET	BUFN + 1
      0 U08b5					      DEFBUF	A_PF2_RIGHT
      1 U08b5		       00 00 00 00*_BUF_A_PF2_RIGHT ds	ARENA_BUFFER_SIZE
      2 U08b5				   BUFN       SET	BUFN + 1
      0 U097e					      DEFBUF	B_PF0_LEFT
      1 U097e		       00 00 00 00*_BUF_B_PF0_LEFT ds	ARENA_BUFFER_SIZE
      2 U097e				   BUFN       SET	BUFN + 1
      0 U0a47					      DEFBUF	B_PF1_LEFT
      1 U0a47		       00 00 00 00*_BUF_B_PF1_LEFT ds	ARENA_BUFFER_SIZE
      2 U0a47				   BUFN       SET	BUFN + 1
      0 U0b10					      DEFBUF	B_PF2_LEFT
      1 U0b10		       00 00 00 00*_BUF_B_PF2_LEFT ds	ARENA_BUFFER_SIZE
      2 U0b10				   BUFN       SET	BUFN + 1
      0 U0bd9					      DEFBUF	B_PF0_RIGHT
      1 U0bd9		       00 00 00 00*_BUF_B_PF0_RIGHT ds	ARENA_BUFFER_SIZE
      2 U0bd9				   BUFN       SET	BUFN + 1
      0 U0ca2					      DEFBUF	B_PF1_RIGHT
      1 U0ca2		       00 00 00 00*_BUF_B_PF1_RIGHT ds	ARENA_BUFFER_SIZE
      2 U0ca2				   BUFN       SET	BUFN + 1
      0 U0d6b					      DEFBUF	B_PF2_RIGHT
      1 U0d6b		       00 00 00 00*_BUF_B_PF2_RIGHT ds	ARENA_BUFFER_SIZE
      2 U0d6b				   BUFN       SET	BUFN + 1
      0 U0e34					      DEFBUF	GRP0A
      1 U0e34		       00 00 00 00*_BUF_GRP0A ds	ARENA_BUFFER_SIZE
      2 U0e34				   BUFN       SET	BUFN + 1
      0 U0efd					      DEFBUF	GRP1A
      1 U0efd		       00 00 00 00*_BUF_GRP1A ds	ARENA_BUFFER_SIZE
      2 U0efd				   BUFN       SET	BUFN + 1
    788 U0fc6
    789 U0fc6		       0e 22	   _BUFFER_BLOCK_SIZE =	* - _BUFFERS
    790 U0fc6
    791 U0fc6							;------------------------------------------------------------------------------
    792 U0fc6
    793 U0fc6
    794 U0fc6
    795 U0fc6		       00 00	   _BUF_AUDV  ds	2
    796 U0fc8		       00 00	   _BUF_AUDC  ds	2
    797 U0fca		       00 00	   _BUF_AUDF  ds	2
    798 U0fcc
    799 U0fcc
    800 U0fcc				   OverlapDisplayDataRam		; mark the beginning of overlapped RAM
    801 U0fcc							; Splash screen datastream buffers
    802 U0fcc							;_BUF_SPLASH0:   ds 192
    803 U0fcc							;_BUF_SPLASH1:   ds 192
    804 U0fcc							;_BUF_SPLASH2:   ds 192
    805 U0fcc							;_BUF_SPLASH3:   ds 192
    806 U0fcc
 ---- $34 Splash bytes of Display Data RAM left
    807 U0fcc					      echo	"----",($1000 - *) , "Splash bytes of Display Data RAM left"
    808 U0fcc							;----------------------------------------
    809 U0fcc							; this ORG overlaps the Menu datastreams on top of the Splash datastreams
    810 U0fcc							;----------------------------------------
    811 U0fcc
    812 U0fcc							; Generic overlap variable usage
    813 U0fcc					      ORG	OverlapDisplayDataRam
 ---- $34 Menu bytes of Example Overlap RAM left
    814 U0fcc					      echo	"----",($1000 - *) , "Menu bytes of Example Overlap RAM left"
    815 U0fcc
    816 U0fcc							;----------------------------------------
    817 U0fcc							; this ORG overlaps the Game datastreams on top of the Splash and Menu datastreams
    818 U0fcc							;----------------------------------------
    819 U0fcc					      ORG	OverlapDisplayDataRam
    820 U0fcc							; Game datastream buffers
    821 U0fcc				   _EVERY_FRAME_ZERO_START
    822 U0fcc
    823 U0fcc					      align	4	; need to be 4 byte aligned to use myMemsetInt
    824 U0fcc		       00 00	   _EVERY_FRAME_ZERO_COUNT =	*-_EVERY_FRAME_ZERO_START	; end of zeroed out data
    825 U0fcc
    826 U0fcc
    827 U0fcc
    828 U0fcc
 ---- $34 Game bytes of Display Data RAM left
    829 U0fcc					      echo	"----",($1000 - *) , "Game bytes of Display Data RAM left"
