//==============================================================================
// CDFJChess by Andrew Davie
// demo Chessboard Display
// derived from  Collect3 ARM routines by Darrell Spice, Jr.
//==============================================================================



//==============================================================================
// Includes
//--------------------------------------
//  defines_cdfj.h
//      defines and functions for CDFJ coprocessor
//  defines_from_dasm_for_c.h
//      auto-generated by the make file, it contains values from the 6507 code
//  defines.h
//      defines to make the code easier to read
//==============================================================================

#include <stdbool.h>

#include "defines_cdfj.h"
#include "defines_from_dasm_for_c.h"
#include "defines.h"

#include "main.h"
#include "bitpatterns.h"

#include "characterset.h"
#include "logo.h"
#include "bitshapes.h"
#include "drawplayer.h"
#include "overlay.h"
#include "drawscreen.h"
#include "cavedata.h"
#include "sound.h"
#include "movePlayer.h"
#include "drawBitmap.h"


////////////////////////////////////////////////////////////////////////////////

void setPalette(int start, int size, int step);
void resetMobileEndpoints();


int pfBuffer;

int parallax;
bool finished = false;
bool swap = false;


unsigned char bgPalette[24];

int tuneIndex;


int doge;
int time;
int level;
int terminalDelay;

bool dripFree;
bool lastDripFree;

extern int caveFlags;

#if ENABLE_SHAKE
int shakeX, shakeY;
int shakeTime;
#endif

#if ENABLE_PARALLAX
#define CHAR_SIZE (PIECE_DEPTH + 9 + 9)

unsigned char parallaxBlank[CHAR_SIZE];
unsigned char charDust3[CHAR_SIZE];

#endif



const int initMapColour[] = {

    1,2,3, 4,5,6, 7,1,2,
    3,4,5, 6,7,1, 2,3,4,
    5,6,7, 1,2,3, 4,5,6,
    3,4,5, 6,7,1, 2,3,4,
    5,6,7, 1,2,3, 4,5,6,
    1,2,3, 4,5,6, 7,1,2,
};



int fLayer = 0;
int layer = 0;
int initSpeed[3] = { 1,3,5};
int direct[3] = {0,0,0};
int fno = 0;
int rotateTop[] = {0,0,0};
int rotateSpeed[] = {1,1,1};


#define FACETS 54

char mobileFacetX[FACETS];
char mobileFacetY[FACETS];
char mobileFacetEndX[FACETS];
char mobileFacetEndY[FACETS];
char mobileDrawOrder[FACETS];
char mobileCol[FACETS];

const int facetX[];
const int facetY[];



//==============================================================================
// Variables
//--------------------------------------
// Within C there are rules about where a variable can be seen based on where it
// is defined.  This is known as scope:
//      https://www.tutorialspoint.com/cprogramming/c_scope_rules.htm
//
// Very brief summary of scope:
//
//  Global Variable - variables defined outside of a function can be used by ANY function.
//  Local Variable - variables defined inside a function can be use by ONLY that function.
//
// The ARM used in the Harmony/Melody does not support floating point values, so
// we can only use data types of char and int. These types can be modified with
// unsigned and/or short to change the range of values that can be represented.
//
// signed char        =  8 bit, 1 byte,  range is           -128 to           127
// char               =  8 bit, 1 byte,  range is              0 to           255
// unsigned char      =  8 bit, 1 byte,  range is              0 to           255
// short int          = 16 bit, 2 bytes, range is        -32,768 to        32,767
// unsigned short int = 16 bit, 2 bytes, range is              0 to        65,535
// int                = 32 bit, 4 bytes, range is -2,147,483,648 to 2,147,483,647
// unsigned int       = 32 bit, 4 bytes, range is              0 to 4,294,967,295
//
// NOTE: variables of int and unsigned int result in smaller/faster code, but
// are not always practical to use due to limited amount of RAM available.
//
// When referencing data defined in the 6507 code:
//      BYTE = char (range -128 to 127)
//      BYTE = unsigned char (range 0 to 255)
//      WORD = short int (range -32768 to 32767)
//      WORD = unsigned short int (range 0 to 65535)
//
// NOTE: WORD data that will be used by the ARM must be on 2 byte boundaries.
//
//==============================================================================


// enum FLAG {
//     FLAG_THISFRAME = 0x80,
// };



unsigned char is_7800;  // 0 = 2600, non-zero = 7800

// Image Data

//const unsigned char *arena_increments =(unsigned char *)_ARENA_INCREMENTS;

unsigned char mm_tv_type = 0;  // 0 = NTSC, 1 = PAL, 2 = SECAM

enum Direction rockfordDirection = RIGHT;

int frameAdjustX;
int frameAdjustY;
int frameAdjustSmallX;
int frameAdjustSmallY;


unsigned int frameCounter;
unsigned int frameToggler;
unsigned int gameSpeed;
unsigned int toggler;


// #define DISPLAY_NORMAL 0

//#define DISPLAY_OVERVIEW 1
#define DISPLAY_NONE 2

unsigned char displayMode, lastDisplayMode;

//unsigned char joy0FireBuffer = 0xFF;
unsigned int triggerPressCounter = 0;
unsigned int dogeCollected;

//#define PUSH_DELAY 10
// #define DELAY_AFTER_PUSH 3
unsigned int pushCounter;
unsigned int halt;


// unsigned int uncoverCount;
int rockfordX, rockfordY;
bool rockfordDead;
int lives;


int diamondValue;
int extraDogeCoinValue;

int amoebaCounter = 0;
int amoebaGrew = 1;
int lastAmoebaGrew = 0;
int cave = 0;
unsigned char bufferedSWCHA = 0xFF;

unsigned int maxScrollXSpeed;



int controlledLayer = 0;
int highlightLayer = 0;
bool showHighlight = false;
int jDelay = 0;
int changedLayer = 0;
int lastJOY0_FIRE = 0;
int drawMode = 1;
int facetIndex = 0;


// COMPILE-TIME REVERSE BITS IN BYTE
#define RVS(a) ( \
      ((((a) >> 0) & 1) << 7) \
    | ((((a) >> 1) & 1) << 6) \
    | ((((a) >> 2) & 1) << 5) \
    | ((((a) >> 3) & 1) << 4) \
    | ((((a) >> 4) & 1) << 3) \
    | ((((a) >> 5) & 1) << 2) \
    | ((((a) >> 6) & 1) << 1) \
    | ((((a) >> 7) & 1) << 0) \
    )

#define P0(a) RVS(a)
#define P1(a) P0(a), P0(a+1)
#define P2(a) P1(a), P1(a+2)
#define P3(a) P2(a), P2(a+4)
#define P4(a) P3(a), P3(a+8)
#define P5(a) P4(a), P4(a+16)
#define P6(a) P5(a), P5(a+32)
#define P7(a) P6(a), P6(a+64)
#define P8(a) P7(a), P7(a+128)

// Want to call RVS(n) for 0-255 values. The weird #defines above aloow a single-call
// It's effectively a recursive power-of-two call of the base RVS macro

const unsigned char BitRev[] = {
    P8(0),
};


int scrollX;                // 16.16 PF pixels
int scrollY;                // 16.16 TRI pixel lines



int scrollSpeed = 0, scrollYSpeed = 0;
int targetScrollSpeed = 0, targetYScrollSpeed = 0;




//==============================================================================
// Contstants
//--------------------------------------
// Contstants do not change their value at runtime, so are stored in ROM.
//
// WARNING: If the const is left off the values will be stored in ROM, but then
// copied into RAM when the Harmony/Melody is turned on.
//==============================================================================


const unsigned char NTSCtoPAL[16] =
{
    // SeaGtGruff's conversion values from this post at AtariAge:
    // https://atariage.com/forums/topic/165424-modify-colour-palette/?do=findComment&comment=2043124
    0x00, 0x20, 0x20, 0x40, 0x40, 0x80, 0xa0, 0xc0,
    0xb0, 0xb0, 0x90, 0x70, 0x50, 0x30, 0x30, 0x20
};

// const unsigned char NTSCtoSECAM[16] =
// {
//     0x0e,   // 0 = white            e = white
//     0x0c,   // 1 = yellow           c = yellow
//     0x0c,   // 2 = yellowish orange c = yellow
//     0x04,   // 3 = reddish orange   4 = red
//     0x04,   // 4 = red              4 = red
//     0x06,   // 5 = reddish purple   6 = purple
//     0x06,   // 6 = purple           6 = purple
//     0x06,   // 7 = bluish purple    6 = purple
//     0x02,   // 8 = blue             2 = blue
//     0x02,   // 9 = blue             2 = blue
//     0x0a,   // a = bluish cyan      a = cyan
//     0x0a,   // b = cyan             a = cyan
//     0x08,   // c = green            8 = green
//     0x08,   // d = green            8 = green
//     0x08,   // e = olive green      8 = green
//     0x0c    // f = brown            c = yellow
// };

enum DIR {
    DIR_UP = 1,
    DIR_DOWN = 2,
    DIR_LEFT = 4,
    DIR_RIGHT = 8,
};

const int xInc[] = {

        // RLDU
    0,  // 0000
    0,  // 0001
    0,  // 0010
    0,  // 0011
    -1, // 0100
    -1, // 0101
    -1, // 0110
    0,  // 0111
    1,  // 1000
    1,  // 1001
    1,  // 1010
    0,  // 1011
    0,  // 1100
    0,  // 1101
    0,  // 1110
    0,  // 1111
};

const int yInc[] = {

        // RLDU
    0,  // 0000
    -1, // 0001
    1,  // 0010
    0,  // 0011
    0,  // 0100
    -1, // 0101
    1,  // 0110
    0,  // 0111
    0,  // 1000
    -1, // 1001
    1,  // 1010
    0,  // 1011
    0,  // 1100
    0,  // 1101
    0,  // 1110
    0,  // 1111
};


// Function Prototypes

unsigned char ColourConvert(unsigned char);
void GameOverscan();
void GameVerticalBlank();
void InitGameBuffers();
void Initialize();
void drawScreen();
void Scheduler();
void SetupBoard();


void drawOverviewScreen();
unsigned int getRandom32();




//==============================================================================
// Function Definitions
//--------------------------------------
// main() is the initial function called when running C code. Main is defined as
// returning an int value. You could change it to void and it will still work;
// however, it will introduce compile time warnings, and unlike using void for
// other functions using void for main() will not save any ROM.
//==============================================================================


unsigned char ColourConvert(unsigned char color) {

    if (mm_tv_type == PAL) {
        return NTSCtoPAL[color>>4] +    // convert chroma value
               (color & 0x0f);          // retain luma value
    }

    // else if (mm_tv_type == SECAM) {
    //     return color < 2 ? 0 : NTSCtoSECAM[color>>4];
    // }

    // else
        return color;
}



enum SCHEDULE {
    SCHEDULE_UNPACK_CAVE,
    SCHEDULE_START,
    SCHEDULE_PROCESSBOARD,
};

enum SCHEDULE gameSchedule = SCHEDULE_START;

const int cnoNext[] = { 1, 2, 0 };


int main() {

    // main() is called when the 6507 code writes to CALLFN.
    // The 6507 code sets the value of RUN_FUNC.
    
    switch (RUN_FUNC)
    {
    case _FN_INIT:
        Initialize();
        break;

    case _FN_GAME_OS:
        GameOverscan();
        break;

    case _FN_GAME_VB:
        GameVerticalBlank();
        break;

    case _FN_GAME_IDLE:
        Scheduler();
        break;
    }
    
    return 0;
}







void setColours() {

    unsigned char i;
    unsigned char colour[3];

    for (i = 0; i < 3; i++)
        colour[i] = ColourConvert(caveList[cave].caveColour[0][i]);

/*    if (attractCounter > ATTRACT_TRIGGER) {
        unsigned char colbase = getRandom32();
        for (i = 0; i < 3; i++)
            colour[i] = ((colour[i] ^ colbase ) + i * 0x50) & 0xF2;
        ARENA_COLOR = colbase & 0xF0;
    }
*/

    // unsigned char scorecol = lives? 0x29 : 0x49;
    unsigned char bgCol = 0;

    i = 0;
    // if (displayMode == DISPLAY_NORMAL)
    //     while (i < SCORE_SCANLINES) {
    //         RAM[_BUF_COLUPF + i] = ColourConvert(scorecol);
    //         RAM[_BUF_COLUBK + i] = bgCol;
            
    //         scorecol -= (i + (i>>1))>>4;
    //         i++;
    //     }

    unsigned char cno = 0;
    while (i < _ARENA_SCANLINES) {
        RAM[_BUF_COLUPF + i] = ColourConvert(colour[cno]);
        RAM[_BUF_COLUBK + i] = bgCol;
        cno = cnoNext[cno];
        i++;
    }


}

bool hasTopFace[] = {

    false, false, false, false,
    false, false, false, false,
    false, false, true, true,
    true, true, true, true,
    true, true, true,

};

bool hasRightFace[] = {

    false, true, false, true,
    true, false, true, false,
    true, true, false, false,
    false, false, false, true,
    false, true, true,
};

bool hasLeftFace[] = {

    true, false, true, false,
    true, true, false, true,
    false, true, false, false,
    false, true, false, false,
    true, false, true,
};




void InitGameX() {


#if ENABLE_PARALLAX

    // setup RAM chars to contain correct overview-mode char defs
    for (int i = 0; i < CHAR_SIZE; i++) {
        parallaxBlank[i] = 0;
    }

#endif



    drawMode = 1;


    dripFree = true;

#if ENABLE_SHAKE
    shakeTime = 0;
    shakeX = 0;
    shakeY = 0;
#endif

extern int looneyIndex;
extern int looneyY;

    looneyIndex = 0;
    looneyY = 0x400;

extern int radius;
extern int rinc;

    radius = 0;
    rinc = 100;

    rockfordX = 1;
    rockfordY = 19;
    tuneIndex = -1;

    gameSchedule = SCHEDULE_START;
    
    KillRepeatingAudio();

    pushCounter = 0;
    halt = 0;


    amoebaGrew = 1;
    lastDisplayMode = DISPLAY_NONE;


    bufferedSWCHA = 0xFF;

//    joy0FireBuffer = 0xFF;

    dogeCollected = 0;

    scrollSpeed = 0;
    scrollYSpeed = 0;
    rockfordDead = false;

    gameSpeed = GAMESPEED * DEBUG_SLOWDOWN; //12;
    frameCounter = gameSpeed;               // force initial 

    scrollX = 0x0000; //((((getRandom32() & 0xFF) * 38) >> 8) + 1) << 16;
    scrollY = 0x600000; //((((getRandom32() & 0xFF) * 20) >> 8) + 1) << 16;


    InitAudio();
    AddAudio(SFX_TICK);


    frameAdjustX = frameAdjustY = 0;
    frameAdjustSmallX = frameAdjustSmallY = 0;
    rockfordDirection = 1;


    for (int bgLine = 0; bgLine < 24; bgLine++)
        bgPalette[bgLine] = caveList[cave].caveColour[0][0]; //3+ bgLine];


    gameSchedule = SCHEDULE_UNPACK_CAVE;
}

void initFacets() {
    facetIndex = 0;
    resetMobileEndpoints();

    for (int facet = 0; facet < FACETS; facet++) {
 
 
        do
        {
            mobileCol[facet] = getRandom32() & 7;
        } while (mobileCol[facet] == 0);
        
 
 
        int r = (((getRandom32() & 0xFF) * 160)) >> 8;
        r *= r;
        r >>= 11;

        if (getRandom32() & 1)
            r = -r;


        mobileFacetX[facet] = 18 + r;

        r = (((getRandom32() & 0xFF) * 220)) >> 8;
        r *= r;
        r >>= 11;

        if (getRandom32() & 1)
            r = -r;

        mobileFacetY[facet] = 30 + r; // + (r * r < 0? -r : r);

        mobileDrawOrder[facet] = facet;
        //mobileFacetColour[facet] = initMapColour[facet];
    }

}

void Initialize() {
    
    // during Initialize() SWCHA contains the results of the 6507 routine which
    // detects if the console is a 2600 or 7800.
    is_7800 = SWCHA;    // 0 = 2600, non-zero = 7800
        
    // When the Harmon/y Melody is powered up the 4K of Display Data RAM will
    // contain random values, so we should zero it out to have a known starting
    // point. Using myMemsetInt is faster than using myMemset, but requires
    // dividing the number of bytes by 4 because an integer is stored in 4 bytes.

    for (int i = 0; i < 4096/4; i++)
        RAM_INT[i] = 0;

    // for (int i = 0; i < 40; i++)
    //     RAM[_SHAKE_FIX + i] = CH_STEEL;

    //myMemsetInt(RAM_INT, 0, 4096/4);
    
    // likewise the datastream increments will be random, so set them to 1.0
    for(int i = 0; i <= 34; i++)
        setIncrement(i, 1, 0);


    cave = 0;
    lives = 3;
    level = 0;


    pfBuffer = 0;


    initFacets();



    InitAudio();
    InitGameX();

    InitGameBuffers();

    drawMode = 1;

    setPalette(0, PIECE_DEPTH, 3);
}


void GameScheduleAnimate();
void GameScheduleProcessBoardRow();



void Scheduler() {

    switch (gameSchedule) {
    case SCHEDULE_UNPACK_CAVE:
        gameSchedule = SCHEDULE_START;
        break;
    case SCHEDULE_START:
        SetupBoard();
        break;
    case SCHEDULE_PROCESSBOARD:
        GameScheduleProcessBoardRow();
        break;
    default:
        break;
    }
}

const unsigned int bufPtr[][2]= {

    { _BUF_A_PF0_LEFT, _BUF_B_PF0_LEFT },
    { _BUF_A_PF1_LEFT, _BUF_B_PF1_LEFT },
    { _BUF_A_PF2_LEFT, _BUF_B_PF2_LEFT },

    { _BUF_A_PF0_RIGHT, _BUF_B_PF0_RIGHT },
    { _BUF_A_PF1_RIGHT, _BUF_B_PF1_RIGHT },
    { _BUF_A_PF2_RIGHT, _BUF_B_PF2_RIGHT },
};


void InitGameDatastreams() {

    int visibleBuffer = pfBuffer ^ 1;

    // initialize the Data Streams for the Arena
    setPointer(_DS_PF0_LEFT,  bufPtr[0][visibleBuffer]);
    setPointer(_DS_PF1_LEFT,  bufPtr[1][visibleBuffer]);
    setPointer(_DS_PF2_LEFT,  bufPtr[2][visibleBuffer]);
    setPointer(_DS_PF0_RIGHT, bufPtr[3][visibleBuffer]);
    setPointer(_DS_PF1_RIGHT, bufPtr[4][visibleBuffer]);
    setPointer(_DS_PF2_RIGHT, bufPtr[5][visibleBuffer]);

    setPointer(_DS_AUDV0, _BUF_AUDV);
    setPointer(_DS_AUDC0, _BUF_AUDC);
    setPointer(_DS_AUDF0, _BUF_AUDF);

    setPointer(_DS_COLUPF, _BUF_COLUPF);
    setPointer(_DS_COLUBK, _BUF_COLUBK);
    setPointer(_DS_COLUP0, _BUF_COLUP0);
    setPointer(_DS_COLUP1, _BUF_COLUP1);

    setPointer(_DS_GRP0a, _BUF_GRP0A);
    setPointer(_DS_GRP1a, _BUF_GRP1A);

    // initialize the Jump Data Stream
    setPointer(0x21, _BUF_JUMP1);
}


//==============================================================================
// Game routines
//--------------------------------------
//  All game logic runs in OverScan
//  All prep of the datastreams runs in Vertical Blank
//==============================================================================




void GameOverscan() {
    playAudio();
}





#define PULSE 0 /*0x80*/

const int facetEndX[];
const int facetEndY[];

void rotateLeft(int face) {

    switch (face) {

    case 0:
        {                
            mobileFacetEndX[0] = facetEndX[6];
            mobileFacetEndY[0] = facetEndY[6];
            mobileFacetEndX[1] = facetEndX[3];
            mobileFacetEndY[1] = facetEndY[3];
            mobileFacetEndX[2] = facetEndX[0];
            mobileFacetEndY[2] = facetEndY[0];
            mobileFacetEndX[3] = facetEndX[7];
            mobileFacetEndY[3] = facetEndY[7];
            mobileFacetEndX[5] = facetEndX[1];
            mobileFacetEndY[5] = facetEndY[1];
            mobileFacetEndX[6] = facetEndX[8];
            mobileFacetEndY[6] = facetEndY[8];
            mobileFacetEndX[7] = facetEndX[5];
            mobileFacetEndY[7] = facetEndY[5];
            mobileFacetEndX[8] = facetEndX[2];
            mobileFacetEndY[8] = facetEndY[2];


            mobileFacetEndX[9] = facetEndX[53];
            mobileFacetEndY[9] = facetEndY[53];
            mobileFacetEndX[12] = facetEndX[50];
            mobileFacetEndY[12] = facetEndY[50];
            mobileFacetEndX[15] = facetEndX[47];
            mobileFacetEndY[15] = facetEndY[47];

            mobileFacetEndX[47] = facetEndX[33];
            mobileFacetEndY[47] = facetEndY[33];
            mobileFacetEndX[50] = facetEndX[30];
            mobileFacetEndY[50] = facetEndY[30];
            mobileFacetEndX[53] = facetEndX[27];
            mobileFacetEndY[53] = facetEndY[27];

            mobileFacetEndX[27] = facetEndX[18];
            mobileFacetEndY[27] = facetEndY[18];
            mobileFacetEndX[30] = facetEndX[21];
            mobileFacetEndY[30] = facetEndY[21];
            mobileFacetEndX[33] = facetEndX[24];
            mobileFacetEndY[33] = facetEndY[24];

            mobileFacetEndX[18] = facetEndX[9];
            mobileFacetEndY[18] = facetEndY[9];
            mobileFacetEndX[21] = facetEndX[12];
            mobileFacetEndY[21] = facetEndY[12];
            mobileFacetEndX[24] = facetEndX[15];
            mobileFacetEndY[24] = facetEndY[15];




            mobileCol[0] |= PULSE;
            mobileCol[1] |= PULSE;
            mobileCol[2] |= PULSE;
            mobileCol[3] |= PULSE;
            mobileCol[5] |= PULSE;
            mobileCol[6] |= PULSE;
            mobileCol[7] |= PULSE;
            mobileCol[8] |= PULSE;
            mobileCol[9] |= PULSE;
            mobileCol[12] |= PULSE;
            mobileCol[15] |= PULSE;
            mobileCol[47] |= PULSE;
            mobileCol[50] |= PULSE;
            mobileCol[53] |= PULSE;
            mobileCol[27] |= PULSE;
            mobileCol[30] |= PULSE;
            mobileCol[33] |= PULSE;
            mobileCol[18] |= PULSE;
            mobileCol[21] |= PULSE;
            mobileCol[24] |= PULSE;


        }
        break;

    default:
        break;
    }


}

const int facetEndX[];
const int facetEndY[];

void resetMobileEndpoints() {

    for (int facet = 0; facet < FACETS; facet++) {
        mobileFacetEndX[facet] = facetEndX[facet];
        mobileFacetEndY[facet] = facetEndY[facet];
    }
}

void redoDrawOrder() {

    for (int f = FACETS-1; f >= 0; f--)
        mobileDrawOrder[f] = f;

    int prior = FACETS-1;
    for (int f = FACETS-1; f >= 0; f--) {

        if ((mobileFacetX[f] != mobileFacetEndX[f])
            || (mobileFacetY[f] != mobileFacetEndY[f])) {
            mobileDrawOrder[f] = mobileDrawOrder[prior];
            mobileDrawOrder[prior] = f;
            prior--;
        }
    }
}

char moving = 0;


bool canMove() {
    for (int facet = 0; facet < FACETS; facet++)
        if (mobileFacetX[facet] != mobileFacetEndX[facet] || mobileFacetY[facet] != mobileFacetEndY[facet])
            return false;

    return true;
}



void HandleJoystick() {


    if (!drawMode) {


        if (JOY0_LEFT) {

            if (facetIndex == 0 && canMove()) {
                rotateLeft(0);
                redoDrawOrder();
            }
        }

        else if (JOY0_RIGHT && canMove()) {
            if (facetIndex == 0) {
                rotateLeft(0);
                rotateLeft(0);
                rotateLeft(0);
                redoDrawOrder();
            }
        }

        else if (!swap && (!JOY0_FIRE && lastJOY0_FIRE))
            swap = true;



    }


    else {

        if (!jDelay && !highlightLayer) {

            if (JOY0_UP) {

                highlightLayer = 3;
                jDelay = 10;
                changedLayer = 10;
                controlledLayer++;
                if (controlledLayer > 2)
                    controlledLayer = 0;

            }

            else if (JOY0_DOWN) {

                highlightLayer = 3;
                jDelay = 10;
                changedLayer = 10;
                controlledLayer--;
                if (controlledLayer < 0)
                    controlledLayer = 2;
            }

            else if (JOY0_LEFT && !((rotateTop[0]|rotateTop[1]|rotateTop[2]) & 3)) {


                if (JOY0_FIRE)
                    for (int layer = 0; layer < 3; layer++) {
                        rotateSpeed[layer] = 1;
                        direct[layer] = 1;
    //                    rotateTop[layer] &= !3;
                    }


                direct[controlledLayer] = 1;

    //            AddAudio(SFX_PUSH);

            }


            else if (JOY0_RIGHT && !((rotateTop[0]|rotateTop[1]|rotateTop[2]) & 3)) {

                if (JOY0_FIRE)
                    for (int layer = 0; layer < 3; layer++) {
                        rotateSpeed[layer] = 1;
                        direct[layer] = -1;
    //                    rotateTop[layer] &= !3;
                    }


                direct[controlledLayer] = -1;
    //            AddAudio(SFX_PUSH);
            }

            else if (!swap && (!JOY0_FIRE && lastJOY0_FIRE)) {
                swap = true;

                initFacets();



            }



        }
    }

    lastJOY0_FIRE = JOY0_FIRE;


    if (jDelay)
        jDelay--;
}




void setPalette(int start, int size, int step) {

    setColours();

    int bgCharLine = (scrollY >> 16) * 3;
    int absLine = 0;
    int pfCharLine = 0;
    
    if (start) {
        absLine = bgCharLine;
        bgCharLine--;

        while (bgCharLine >= size) {
            bgCharLine -= size;
            pfCharLine++;
        }
    }



    int i = start;
    while (i < _ARENA_SCANLINES) {


        RAM[_BUF_COLUPF + i] = ColourConvert(bgPalette[pfCharLine]);
        
            
        bgCharLine += 3;            
        if (bgCharLine >= size) {
            bgCharLine = 0;
            pfCharLine++;
        }


        absLine += step;
        i+=3;
    }

}




void setOverviewPalette() {

    setPalette(0, 9, 7);

}

void setDisplayPalette() {
//    setPalette(0, PIECE_DEPTH, 3, 3);
}


const unsigned char *shapeSetFacet[];


void drawOverviewSoftwareSprites() {


    int f = mobileDrawOrder[facetIndex];

    int col = mobileCol[f];
    if (col & PULSE ) {
        mobileCol[f] &= ~PULSE;
        col = 7;
    } else {


        if (mobileFacetX[f] < mobileFacetEndX[f]) {

            int rspeed = mobileFacetEndX[f] - mobileFacetX[f];
            rspeed >>= 1;
            rspeed++;
            // if (rspeed > 2)
            //     rspeed = 2;

            mobileFacetX[f] += rspeed; //((mobileFacetEndX[f] - mobileFacetX[f]) >> 3) + 1;
            // mobileCol[f] ^= PULSE;
            // if (mobileFacetX[f] == mobileFacetEndX[f] && mobileFacetY[f] == mobileFacetEndY[f])
            //     mobileCol[f] |= PULSE;
        }

        if (mobileFacetY[f] < mobileFacetEndY[f]) {

            int rspeed = mobileFacetEndY[f] - mobileFacetY[f];
            rspeed >>= 1;
            rspeed++;
            // if (rspeed > 5)
            //     rspeed = 5;

            mobileFacetY[f] += rspeed; //((mobileFacetEndY[f] - mobileFacetY[f]) >> 2) + 1;
            // mobileCol[f] ^= PULSE;
            // if (mobileFacetX[f] == mobileFacetEndX[f] && mobileFacetY[f] == mobileFacetEndY[f])
            //     mobileCol[f] |= PULSE;
        }

        if (mobileFacetX[f] > mobileFacetEndX[f]) {

            int rspeed = mobileFacetX[f] - mobileFacetEndX[f];
            rspeed >>= 1;
            rspeed++;
//            mobileFacetX[f] += rspeed; //((mobileFacetEndX[f] - mobileFacetX[f]) >> 3) + 1;
            //     rspeed = 2;

            mobileFacetX[f] -= rspeed; //((mobileFacetX[f] - mobileFacetEndX[f]) >> 3) + 1;
            // mobileCol[f] ^= PULSE;
            // if (mobileFacetX[f] == mobileFacetEndX[f] && mobileFacetY[f] == mobileFacetEndY[f])
            //     mobileCol[f] |= PULSE;
        }

        if (mobileFacetY[f] > mobileFacetEndY[f]) {

            int rspeed = mobileFacetY[f] - mobileFacetEndY[f];
            rspeed >>= 1;
            rspeed++;
            // if (rspeed > 5)
            //     rspeed = 5;

            mobileFacetY[f] -= rspeed; //((mobileFacetY[f] - mobileFacetEndY[f]) >> 2) + 1;
            // mobileCol[f] ^= PULSE;
            // if (mobileFacetX[f] == mobileFacetEndX[f] && mobileFacetY[f] == mobileFacetEndY[f])
            //     mobileCol[f] |= PULSE;
        }

    }

    drawBitmap(shapeSetFacet[col],
        ((mobileFacetX[f] << 14) & 0xFFFFC000) + 0x00004000,
        ((100 + mobileFacetY[f]) << 16)   * 3,
        true);

    if (++facetIndex >= FACETS) {
        facetIndex = 0;
        finished = true;
    }
}


#define AXES 1
#define ROTATE 16


struct facet {
    int face;
    int colour;
    int x;
    int y;
    int square;
    bool topOnly;
};


#define MARKER 0


struct facet shapeDef[AXES][ROTATE][25] = {

    {

        // 0  ISO
         
        {   // THIS GROUPING DEFINES DISPLAY OF A LAYER (e.g, one row or column of a cube)

            // multiple facets, each...
            // visibleShape, colour, x, y, face# (to get colour), topOnly

            // visibleShape:
            // 0                TOP
            // 1                LEFT
            // 2                RIGHT
            // 3    ... more rotations to be added


            // topOnly:
            // true             a part of the 3x3 "top" of the layer
            // false            always drawn


            // left facets

            {   1, 6,   4, 0x140000,   6,    false,   },       // L0
            {   1, 1,   9, 0x190000,   7,    false,   },       // L1
            {   1, 3,  14, 0x1E0000,   8,    false,   },       // L2 (@CENTER)

            // right facets

            {   2, 3,  24, 0x140000,   6,    false,   },
            {   2, 1,  19, 0x190000,   7,    false,   },
            {   2, 6,  14, 0x1E0000,   8,    false,   },

            // top facets

            {   0, 2,  14, 0x0A0000,   0,    true,    },
            {   0, 1,   9, 0x0F0000,   1,    true,    },
            {   0, 2,  19, 0x0F0000,   2,    true,    },
            {   0, 3,   4, 0x140000,   3,    true,    },
            {   0, 4,  14, 0x140000,   4,    true,    },
            {   0, 5,  24, 0x140000,   5,    true,    },
            {   0, 6,   9, 0x190000,   6,    true,    },
            {   0, 7,  19, 0x190000,   7,    true,    },
            {   0, 1,  14, 0x1E0000,   8,    true,    },




            {   -1,  -1, 0,0,0,    false,   },
        },
 

        // 1 tilt

        {   // THIS GROUPING DEFINES DISPLAY OF A LAYER (e.g, one row or column of a cube)

            // multiple facets, each...
            // visibleShape, x, y, face# (to get colour), topOnly

            // visibleShape:
            // 0                TOP
            // 1                LEFT
            // 2                RIGHT
            // 3    ... more rotations to be added


            // topOnly:
            // true             a part of the 3x3 "top" of the layer
            // false            always drawn


            // {   8, 0,  4, 0x150000,   0,    false,    },       // cube boundary
            // {   8, 1, 14, 0x1E0000,   0,    false,    },       // cube boundary


#define AX1 1
#define AY1 -0x20000


            // left facets

            {   6, 6,   4+AX1, 0x120000+AY1,   6,    false,   },       // L0
            {   6, 1,   7+AX1, 0x190000+AY1,   7,    false,   },       // L1
            {   6, 3,  10+AX1, 0x200000+AY1,   8,    false,   },       // L2 (@CENTER)

            // right facets

            {   5, 3,  22+AX1, 0x1A0000+AY1,   6,    false,   },
            {   5, 1,  16+AX1, 0x1D0000+AY1,   7,    false,   },
            {   5, 6,  10+AX1, 0x200000+AY1,   8,    false,   },

            // top facets

            {   7, 2,  16+AX1, 0x0C0000+AY1,   0,    true,    },
            {   7, 1,  10+AX1, 0x0f0000+AY1,   1,    true,    },
            {   7, 2,  19+AX1, 0x130000+AY1,   2,    true,    },
            {   7, 3,   4+AX1, 0x120000+AY1,   3,    true,    },
            {   7, 4,  13+AX1, 0x160000+AY1,   4,    true,    },
            {   7, 5,  22+AX1, 0x1A0000+AY1,   5,    true,    },
            {   7, 6,   7+AX1, 0x190000+AY1,   6,    true,    },
            {   7, 7,  16+AX1, 0x1D0000+AY1,   7,    true,    },
            {   7, 1,  10+AX1, 0x200000+AY1,   8,    true,    },

            {   -1,  -1, 0,0,0,    false,   },
        },

        // 2 flat

        {   // THIS GROUPING DEFINES DISPLAY OF A LAYER (e.g, one row or column of a cube)

            // multiple facets, each...
            // visibleShape, x, y, face# (to get colour), topOnly

            // visibleShape:
            // 0                TOP
            // 1                LEFT
            // 2                RIGHT
            // 3    ... more rotations to be added


            // topOnly:
            // true             a part of the 3x3 "top" of the layer
            // false            always drawn

#define AX2 -1
#define AY2 -0x20000


            // {   8, 0,  4, 0x150000,   0,    false,    },       // cube boundary
            // {   8, 1, 14, 0x1E0000,   0,    false,    },       // cube boundary

            // top facets

            {   3, 3,  8+AX2, 0x0F0000+AY2,   0,    true,    },
            {   3, 1, 15+AX2, 0x0F0000+AY2,   1,    true,    },
            {   3, 2, 22+AX2, 0x0F0000+AY2,   2,    true,    },
            {   3, 6,  8+AX2, 0x160000+AY2,   3,    true,    },
            {   3, 4, 15+AX2, 0x160000+AY2,   4,    true,    },
            {   3, 2, 22+AX2, 0x160000+AY2,   5,    true,    },
            {   3, 1,  8+AX2, 0x1D0000+AY2,   6,    true,    },
            {   3, 7, 15+AX2, 0x1D0000+AY2,   7,    true,    },
            {   3, 5, 22+AX2, 0x1D0000+AY2,   8,    true,    },

            // right facets (now face-on)

            {   4, 6,   8+AX2, 0x1D0000+AY2,   6,    false,   },       // L0
            {   4, 1,  15+AX2, 0x1D0000+AY2,   7,    false,   },       // L1
            {   4, 3,  22+AX2, 0x1D0000+AY2,   8,    false,   },       // L2 (@CENTER)


            {   -1,  -1, 0,0,0,    false,   },
        },
 
 
        // 3 tilt2 +(6,0x30000)
        {   // THIS GROUPING DEFINES DISPLAY OF A LAYER (e.g, one row or column of a cube)

            // multiple facets, each...
            // visibleShape, x, y, face# (to get colour), topOnly

            // visibleShape:
            // 0                TOP
            // 1                LEFT
            // 2                RIGHT
            // 3    ... more rotations to be added

#define AX3 -1
#define AY3 -0x20000

            // topOnly:
            // true             a part of the 3x3 "top" of the layer
            // false            always drawn


            // {   8, 0,  4, 0x150000,   0,    false,    },       // cube boundary
            // {   8, 1, 14, 0x1E0000,   0,    false,    },       // cube boundary


            // top facets

            {   9, 3,  12+AX3, 0x0C0000+AY3,   0,    true,    },
            {   9, 1,  18+AX3, 0x0F0000+AY3,   1,    true,    },
            {   9, 6,   9+AX3, 0x130000+AY3,   2,    true,    },
            {   9, 2,  24+AX3, 0x120000+AY3,   3,    true,    },
            {   9, 4,  15+AX3, 0x160000+AY3,   4,    true,    },
            {   9, 2,  21+AX3, 0x190000+AY3,   6,    true,    },
            {   9, 1,   6+AX3, 0x1A0000+AY3,   5,    true,    },
            {   9, 7,  12+AX3, 0x1D0000+AY3,   7,    true,    },
            {   9, 5,  18+AX3, 0x200000+AY3,   8,    true,    },

            // right facets

            {   10, 6,  24+AX3, 0x120000+AY3,   6,    false,   },       // L0
            {   10, 4,  21+AX3, 0x190000+AY3,   7,    false,   },       // L1
            {   10, 4,  18+AX3, 0x200000+AY3,   8,    false,   },       // L2 (@CENTER)

            // left facets

            {   11, 6,   6+AX3, 0x1A0000+AY3,   6,    false,   },
            {   11, 1,  12+AX3, 0x1D0000+AY3,   7,    false,   },
            {   11, 3,  18+AX3, 0x200000+AY3,   8,    false,   },

            {   -1,  -1, 0,0,0,    false,   },
        },

        // 4 ISO

        {   // THIS GROUPING DEFINES DISPLAY OF A LAYER (e.g, one row or column of a cube)

            // multiple facets, each...
            // visibleShape, x, y, face# (to get colour), topOnly

            // visibleShape:
            // 0                TOP
            // 1                LEFT
            // 2                RIGHT
            // 3    ... more rotations to be added

#define AX4 0
#define AY4 0x00000

            // topOnly:
            // true             a part of the 3x3 "top" of the layer
            // false            always drawn

            // top facets

            {   0, 3,  14+AX4, 0x0A0000+AY4,   0,    true,    },
            {   0, 6,   9+AX4, 0x0F0000+AY4,   1,    true,    },
            {   0, 1,  19+AX4, 0x0F0000+AY4,   2,    true,    },
            {   0, 1,   4+AX4, 0x140000+AY4,   3,    true,    },
            {   0, 4,  14+AX4, 0x140000+AY4,   4,    true,    },
            {   0, 2,  24+AX4, 0x140000+AY4,   5,    true,    },
            {   0, 7,   9+AX4, 0x190000+AY4,   6,    true,    },
            {   0, 2,  19+AX4, 0x190000+AY4,   7,    true,    },
            {   0, 5,  14+AX4, 0x1E0000+AY4,   8,    true,    },

            // left facets

            {   1, 6,   4+AX4, 0x140000+AY4,   6,    false,   },       // L0
            {   1, 1,   9+AX4, 0x190000+AY4,   7,    false,   },       // L1
            {   1, 3,  14+AX4, 0x1E0000+AY4,   8,    false,   },       // L2 (@CENTER)

            // right facets

            {   2, 6,  24+AX4, 0x140000+AY4,   6,    false,   },
            {   2, 4,  19+AX4, 0x190000+AY4,   7,    false,   },
            {   2, 4,  14+AX4, 0x1E0000+AY4,   8,    false,   },

            {   -1,  -1, 0,0,0,    false,   },
        },


        // 5 TILT

        {   // THIS GROUPING DEFINES DISPLAY OF A LAYER (e.g, one row or column of a cube)

            // multiple facets, each...
            // visibleShape, x, y, face# (to get colour), topOnly

            // visibleShape:
            // 0                TOP
            // 1                LEFT
            // 2                RIGHT
            // 3    ... more rotations to be added

#define AX5 1
#define AY5 -0x20000

            // topOnly:
            // true             a part of the 3x3 "top" of the layer
            // false            always drawn


            // {   8, 0,  4, 0x150000,   0,    false,    },       // cube boundary
            // {   8, 1, 14, 0x1E0000,   0,    false,    },       // cube boundary


            // top facets

            {   7, 3,  16+AX5, 0x0C0000+AY5,   0,    true,    },
            {   7, 6,  10+AX5, 0x0F0000+AY5,   1,    true,    },
            {   7, 1,  19+AX5, 0x130000+AY5,   2,    true,    },
            {   7, 1,   4+AX5, 0x120000+AY5,   3,    true,    },
            {   7, 4,  13+AX5, 0x160000+AY5,   4,    true,    },
            {   7, 2,  22+AX5, 0x1A0000+AY5,   5,    true,    },
            {   7, 7,   7+AX5, 0x190000+AY5,   6,    true,    },
            {   7, 2,  16+AX5, 0x1D0000+AY5,   7,    true,    },
            {   7, 5,  10+AX5, 0x200000+AY5,   8,    true,    },

            // left facets

            {   6, 6,   4+AX5, 0x120000+AY5,   6,    false,   },       // L0
            {   6, 1,   7+AX5, 0x190000+AY5,   7,    false,   },       // L1
            {   6, 3,  10+AX5, 0x200000+AY5,   8,    false,   },       // L2 (@CENTER)

            // right facets

            {   5, 6,  22+AX5, 0x1A0000+AY5,   6,    false,   },
            {   5, 4,  16+AX5, 0x1D0000+AY5,   7,    false,   },
            {   5, 4,  10+AX5, 0x200000+AY5,   8,    false,   },

            {   -1,  -1, 0,0,0,    false,   },
        },


        // 6 FLAT
        {   // THIS GROUPING DEFINES DISPLAY OF A LAYER (e.g, one row or column of a cube)

            // multiple facets, each...
            // visibleShape, x, y, face# (to get colour), topOnly

            // visibleShape:
            // 0                TOP
            // 1                LEFT
            // 2                RIGHT
            // 3    ... more rotations to be added


#define AX6 -1
#define AY6 -0x20000

            // topOnly:
            // true             a part of the 3x3 "top" of the layer
            // false            always drawn

            // top facets

            {   3, 1,  8+AX6, 0x0F0000+AY6,   0,    true,    },
            {   3, 6, 15+AX6, 0x0F0000+AY6,   1,    true,    },
            {   3, 3, 22+AX6, 0x0F0000+AY6,   2,    true,    },
            {   3, 7,  8+AX6, 0x160000+AY6,   3,    true,    },
            {   3, 4, 15+AX6, 0x160000+AY6,   4,    true,    },
            {   3, 1, 22+AX6, 0x160000+AY6,   5,    true,    },
            {   3, 5,  8+AX6, 0x1D0000+AY6,   6,    true,    },
            {   3, 2, 15+AX6, 0x1D0000+AY6,   7,    true,    },
            {   3, 2, 22+AX6, 0x1D0000+AY6,   8,    true,    },

            // right facets (now face-on)

            {   4, 4,   8+AX6, 0x1D0000+AY6,   6,    false,   },       // L0
            {   4, 4,  15+AX6, 0x1D0000+AY6,   7,    false,   },       // L1
            {   4, 6,  22+AX6, 0x1D0000+AY6,   8,    false,   },       // L2 (@CENTER)

            {   -1,  -1, 0,0,0,    false,   },
        },
 

        // 7 TILT2
         {   // THIS GROUPING DEFINES DISPLAY OF A LAYER (e.g, one row or column of a cube)

            // multiple facets, each...
            // visibleShape, x, y, face# (to get colour), topOnly

            // visibleShape:
            // 0                TOP
            // 1                LEFT
            // 2                RIGHT
            // 3    ... more rotations to be added


            // topOnly:
            // true             a part of the 3x3 "top" of the layer
            // false            always drawn

#define AX7 0
#define AY7 -0x20000

            // {   8, 0,  4, 0x150000,   0,    false,    },       // cube boundary
            // {   8, 1, 14, 0x1E0000,   0,    false,    },       // cube boundary


            // top facets

            {   9, 1,  11+AX7, 0x0C0000+AY7,   0,    true,    },
            {   9, 6,  17+AX7, 0x0F0000+AY7,   1,    true,    },
            {   9, 7,   8+AX7, 0x130000+AY7,   2,    true,    },
            {   9, 3,  23+AX7, 0x120000+AY7,   3,    true,    },
            {   9, 4,  14+AX7, 0x160000+AY7,   4,    true,    },
            {   9, 1,  20+AX7, 0x190000+AY7,   6,    true,    },
            {   9, 5,   5+AX7, 0x1A0000+AY7,   5,    true,    },
            {   9, 2,  11+AX7, 0x1D0000+AY7,   7,    true,    },
            {   9, 2,  17+AX7, 0x200000+AY7,   8,    true,    },

            // right facets

            {   10, 5, 23+AX7, 0x120000+AY7,   6,    false,   },       // L0
            {   10, 5, 20+AX7, 0x190000+AY7,   7,    false,   },       // L1
            {   10, 3, 17+AX7, 0x200000+AY7,   8,    false,   },       // L2 (@CENTER)

            // left facets

            {   11, 4,  5+AX7, 0x1A0000+AY7,   6,    false,   },
            {   11, 4, 11+AX7, 0x1D0000+AY7,   7,    false,   },
            {   11, 6, 17+AX7, 0x200000+AY7,   8,    false,   },


            {   -1,  -1, 0,0,0,    false,   },
        },


        // 8 ISO
         {   // THIS GROUPING DEFINES DISPLAY OF A LAYER (e.g, one row or column of a cube)

            // multiple facets, each...
            // visibleShape, x, y, face# (to get colour), topOnly

            // visibleShape:
            // 0                TOP
            // 1                LEFT
            // 2                RIGHT
            // 3    ... more rotations to be added


#define AX8 0
#define AY8 0x00000

            // topOnly:
            // true             a part of the 3x3 "top" of the layer
            // false            always drawn

            // top facets

            {   0, 1,  14+AX8, 0x0A0000+AY8,   0,    true,    },
            {   0, 7,   9+AX8, 0x0F0000+AY8,   1,    true,    },
            {   0, 6,  19+AX8, 0x0F0000+AY8,   2,    true,    },
            {   0, 5,   4+AX8, 0x140000+AY8,   3,    true,    },
            {   0, 4,  14+AX8, 0x140000+AY8,   4,    true,    },
            {   0, 3,  24+AX8, 0x140000+AY8,   5,    true,    },
            {   0, 2,   9+AX8, 0x190000+AY8,   6,    true,    },
            {   0, 1,  19+AX8, 0x190000+AY8,   7,    true,    },
            {   0, 2,  14+AX8, 0x1E0000+AY8,   8,    true,    },

            // left facets

            {   1, 4,   4+AX8, 0x140000+AY8,   6,    false,   },       // L0
            {   1, 4,   9+AX8, 0x190000+AY8,   7,    false,   },       // L1
            {   1, 6,  14+AX8, 0x1E0000+AY8,   8,    false,   },       // L2 (@CENTER)

            // right facets

            {   2, 5,  24+AX8, 0x140000+AY8,   6,    false,   },
            {   2, 5,  19+AX8, 0x190000+AY8,   7,    false,   },
            {   2, 3,  14+AX8, 0x1E0000+AY8,   8,    false,   },

            {   -1,  -1, 0,0,0,    false,   },
        },

 
        // 9 TILT
        {   // THIS GROUPING DEFINES DISPLAY OF A LAYER (e.g, one row or column of a cube)

            // multiple facets, each...
            // visibleShape, x, y, face# (to get colour), topOnly

            // visibleShape:
            // 0                TOP
            // 1                LEFT
            // 2                RIGHT
            // 3    ... more rotations to be added


            // topOnly:
            // true             a part of the 3x3 "top" of the layer
            // false            always drawn

#define AX9 1
#define AY9 -0x20000


            // {   8, 0,  4, 0x150000,   0,    false,    },       // cube boundary
            // {   8, 1, 14, 0x1E0000,   0,    false,    },       // cube boundary



            // left facets

            {   6, 4,   4+AX9, 0x120000+AY9,   6,    false,   },       // L0
            {   6, 4,   7+AX9, 0x190000+AY9,   7,    false,   },       // L1
            {   6, 6,  10+AX9, 0x200000+AY9,   8,    false,   },       // L2 (@CENTER)

            // right facets

            {   5, 5,  22+AX9, 0x1A0000+AY9,   6,    false,   },
            {   5, 5,  16+AX9, 0x1D0000+AY9,   7,    false,   },
            {   5, 3,  10+AX9, 0x200000+AY9,   8,    false,   },

            // top facets

            {   7, 1,  16+AX9, 0x0C0000+AY9,   0,    true,    },
            {   7, 7,  10+AX9, 0x0F0000+AY9,   1,    true,    },
            {   7, 6,  19+AX9, 0x130000+AY9,   2,    true,    },
            {   7, 5,   4+AX9, 0x120000+AY9,   3,    true,    },
            {   7, 4,  13+AX9, 0x160000+AY9,   4,    true,    },
            {   7, 3,  22+AX9, 0x1A0000+AY9,   5,    true,    },
            {   7, 2,   7+AX9, 0x190000+AY9,   6,    true,    },
            {   7, 1,  16+AX9, 0x1D0000+AY9,   7,    true,    },
            {   7, 2,  10+AX9, 0x200000+AY9,   8,    true,    },

            {   -1,  -1, 0,0,0,    false,   },
        },


        // 10 ISO
        {   // THIS GROUPING DEFINES DISPLAY OF A LAYER (e.g, one row or column of a cube)

            // multiple facets, each...
            // visibleShape, x, y, face# (to get colour), topOnly

            // visibleShape:
            // 0                TOP
            // 1                LEFT
            // 2                RIGHT
            // 3    ... more rotations to be added


            // topOnly:
            // true             a part of the 3x3 "top" of the layer
            // false            always drawn

#define AX10 -1
#define AY10 -0x20000

            // top facets

            {   3, 5,  8+AX10, 0x0F0000+AY10,   0,    true,    },
            {   3, 7, 15+AX10, 0x0F0000+AY10,   1,    true,    },
            {   3, 1, 22+AX10, 0x0F0000+AY10,   2,    true,    },
            {   3, 2,  8+AX10, 0x160000+AY10,   3,    true,    },
            {   3, 4, 15+AX10, 0x160000+AY10,   4,    true,    },
            {   3, 6, 22+AX10, 0x160000+AY10,   5,    true,    },
            {   3, 2,  8+AX10, 0x1D0000+AY10,   6,    true,    },
            {   3, 1, 15+AX10, 0x1D0000+AY10,   7,    true,    },
            {   3, 3, 22+AX10, 0x1D0000+AY10,   8,    true,    },

            // right facets (now face-on)

            {   4, 3,   8+AX10, 0x1D0000+AY10,   6,    false,   },       // L0
            {   4, 5,  15+AX10, 0x1D0000+AY10,   7,    false,   },       // L1
            {   4, 5,  22+AX10, 0x1D0000+AY10,   8,    false,   },       // L2 (@CENTER)

            {   -1,  -1, 0,0,0,    false,   },
        },
 
 

        // 11 tilt2 +(6,0x3000)
         {   // THIS GROUPING DEFINES DISPLAY OF A LAYER (e.g, one row or column of a cube)

            // multiple facets, each...
            // visibleShape, x, y, face# (to get colour), topOnly

            // visibleShape:
            // 0                TOP
            // 1                LEFT
            // 2                RIGHT
            // 3    ... more rotations to be added


            // topOnly:
            // true             a part of the 3x3 "top" of the layer
            // false            always drawn


            // {   8, 0,  4, 0x150000,   0,    false,    },       // cube boundary
            // {   8, 1, 14, 0x1E0000,   0,    false,    },       // cube boundary

#define AX11 0
#define AY11 -0x20000


            // top facets

            {   9, 5,  11+AX11,  0x0C0000+AY11,   0,    true,    },
            {   9, 7,  17+AX11,  0x0F0000+AY11,   1,    true,    },
            {   9, 1,  23+AX11,  0x120000+AY11,   3,    true,    },
            {   9, 2,   8+AX11,  0x130000+AY11,   2,    true,    },
            {   9, 4,  14+AX11,  0x160000+AY11,   4,    true,    },
            {   9, 6,  20+AX11,  0x190000+AY11,   6,    true,    },
            {   9, 2,   5+AX11,  0x1A0000+AY11,   5,    true,    },
            {   9, 1,  11+AX11,  0x1D0000+AY11,   7,    true,    },
            {   9, 3,  17+AX11,  0x200000+AY11,   8,    true,    },

            // right facets

            {   10, 3, 23+AX11,  0x120000+AY11,   6,    false,   },       // L0
            {   10, 1, 20+AX11,  0x190000+AY11,   7,    false,   },       // L1
            {   10, 6, 17+AX11,  0x200000+AY11,   8,    false,   },       // L2 (@CENTER)

            // left facets

            {   11, 3,   5+AX11,  0x1A0000+AY11,   6,    false,   },
            {   11, 5,  11+AX11, 0x1D0000+AY11,   7,    false,   },
            {   11, 5,  17+AX11, 0x200000+AY11,   8,    false,   },

            {   -1,  -1, 0,0,0,    false,   },
        },


        // 12

         {   // THIS GROUPING DEFINES DISPLAY OF A LAYER (e.g, one row or column of a cube)

            // multiple facets, each...
            // visibleShape, x, y, face# (to get colour), topOnly

            // visibleShape:
            // 0                TOP
            // 1                LEFT
            // 2                RIGHT
            // 3    ... more rotations to be added

#define AX12 0
#define AY12 0x00000

            // topOnly:
            // true             a part of the 3x3 "top" of the layer
            // false            always drawn

            // top facets

            {   0, 5,  14+AX12, 0x0A0000+AY12,   0,    true,    },
            {   0, 2,   9+AX12, 0x0F0000+AY12,   1,    true,    },
            {   0, 7,  19+AX12, 0x0F0000+AY12,   2,    true,    },
            {   0, 2,   4+AX12, 0x140000+AY12,   3,    true,    },
            {   0, 4,  14+AX12, 0x140000+AY12,   4,    true,    },
            {   0, 1,  24+AX12, 0x140000+AY12,   5,    true,    },
            {   0, 1,   9+AX12, 0x190000+AY12,   6,    true,    },
            {   0, 6,  19+AX12, 0x190000+AY12,   7,    true,    },
            {   0, 3,  14+AX12, 0x1E0000+AY12,   8,    true,    },

            // left facets

            {   1, 3,   4+AX12, 0x140000+AY12,   6,    false,   },       // L0
            {   1, 5,   9+AX12, 0x190000+AY12,   7,    false,   },       // L1
            {   1, 5,  14+AX12, 0x1E0000+AY12,   8,    false,   },       // L2 (@CENTER)

            // right facets

            {   2, 3,  24+AX12, 0x140000+AY12,   6,    false,   },
            {   2, 1,  19+AX12, 0x190000+AY12,   7,    false,   },
            {   2, 6,  14+AX12, 0x1E0000+AY12,   8,    false,   },

            {   -1,  -1, 0,0,0,    false,   },
        },


        // 13 TILT

        {   // THIS GROUPING DEFINES DISPLAY OF A LAYER (e.g, one row or column of a cube)

            // multiple facets, each...
            // visibleShape, x, y, face# (to get colour), topOnly

            // visibleShape:
            // 0                TOP
            // 1                LEFT
            // 2                RIGHT
            // 3    ... more rotations to be added


            // topOnly:
            // true             a part of the 3x3 "top" of the layer
            // false            always drawn

#define AX13 1
#define AY13 -0x20000

            // {   8, 0,  4, 0x150000,   0,    false,    },       // cube boundary
            // {   8, 1, 14, 0x1E0000,   0,    false,    },       // cube boundary


            // left facets

            {   6, 3,   4+AX13, 0x120000+AY13,   6,    false,   },       // L0
            {   6, 5,   7+AX13, 0x190000+AY13,   7,    false,   },       // L1
            {   6, 5,  10+AX13, 0x200000+AY13,   8,    false,   },       // L2 (@CENTER)

            // right facets

            {   5, 3,  22+AX13, 0x1A0000+AY13,   6,    false,   },
            {   5, 1,  16+AX13, 0x1D0000+AY13,   7,    false,   },
            {   5, 6,  10+AX13, 0x200000+AY13,   8,    false,   },

            // top facets

            {   7, 5,  16+AX13, 0x0C0000+AY13,   0,    true,    },
            {   7, 2,  10+AX13, 0x0F0000+AY13,   1,    true,    },
            {   7, 7,  19+AX13, 0x130000+AY13,   2,    true,    },
            {   7, 2,   4+AX13, 0x120000+AY13,   3,    true,    },
            {   7, 4,  13+AX13, 0x160000+AY13,   4,    true,    },
            {   7, 1,  22+AX13, 0x1A0000+AY13,   5,    true,    },
            {   7, 1,   7+AX13, 0x190000+AY13,   6,    true,    },
            {   7, 6,  16+AX13, 0x1D0000+AY13,   7,    true,    },
            {   7, 3,  10+AX13, 0x200000+AY13,   8,    true,    },

            {   -1,  -1, 0,0,0,    false,   },
        },



        // 14
        {   // THIS GROUPING DEFINES DISPLAY OF A LAYER (e.g, one row or column of a cube)

            // multiple facets, each...
            // visibleShape, x, y, face# (to get colour), topOnly

            // visibleShape:
            // 0                TOP
            // 1                LEFT
            // 2                RIGHT
            // 3    ... more rotations to be added

#define AX14 -1
#define AY14 -0x20000

            // topOnly:
            // true             a part of the 3x3 "top" of the layer
            // false            always drawn

            // top facets

            {   3, 2,  8+AX14, 0x0F0000+AY14,   0,    true,    },
            {   3, 2, 15+AX14, 0x0F0000+AY14,   1,    true,    },
            {   3, 5, 22+AX14, 0x0F0000+AY14,   2,    true,    },
            {   3, 1,  8+AX14, 0x160000+AY14,   3,    true,    },
            {   3, 4, 15+AX14, 0x160000+AY14,   4,    true,    },
            {   3, 7, 22+AX14, 0x160000+AY14,   5,    true,    },
            {   3, 3,  8+AX14, 0x1D0000+AY14,   6,    true,    },
            {   3, 6, 15+AX14, 0x1D0000+AY14,   7,    true,    },
            {   3, 1, 22+AX14, 0x1D0000+AY14,   8,    true,    },

            // right facets (now face-on)

            {   4, 6,   8+AX14, 0x1D0000+AY14,   6,    false,   },       // L0
            {   4, 1,  15+AX14, 0x1D0000+AY14,   7,    false,   },       // L1
            {   4, 3,  22+AX14, 0x1D0000+AY14,   8,    false,   },       // L2 (@CENTER)


            {   -1,  -1, 0,0,0,    false,   },
        },
 
 
        // 15 tilt2  +(6,0x30000)
         {   // THIS GROUPING DEFINES DISPLAY OF A LAYER (e.g, one row or column of a cube)

            // multiple facets, each...
            // visibleShape, x, y, face# (to get colour), topOnly

            // visibleShape:
            // 0                TOP
            // 1                LEFT
            // 2                RIGHT
            // 3    ... more rotations to be added


            // topOnly:
            // true             a part of the 3x3 "top" of the layer
            // false            always drawn

#define AX15 0
#define AY15 -0x20000

            // {   8, 0,  4, 0x150000,   0,    false,    },       // cube boundary
            // {   8, 1, 14, 0x1E0000,   0,    false,    },       // cube boundary



            // // right facets

            {   10, 3,  23+AX15, 0x120000+AY15,   6,    false,   },       // L0
            {   10, 1,  20+AX15, 0x190000+AY15,   7,    false,   },       // L1
            {   10, 6,  17+AX15, 0x200000+AY15,   8,    false,   },       // L2 (@CENTER)

            // left facets

            {   11, 6,   5+AX15, 0x1A0000+AY15,   6,    false,   },
            {   11, 1,  11+AX15, 0x1D0000+AY15,   7,    false,   },
            {   11, 3,  17+AX15, 0x200000+AY15,   8,    false,   },

            // top facets

            {   9, 2,  11+AX15, 0x0C0000+AY15,   0,    true,    },
            {   9, 2,  17+AX15, 0x0F0000+AY15,   1,    true,    },
            {   9, 1,   8+AX15, 0x130000+AY15,   2,    true,    },
            {   9, 5,  23+AX15, 0x120000+AY15,   3,    true,    },
            {   9, 4,  14+AX15, 0x160000+AY15,   4,    true,    },
            {   9, 7,  20+AX15, 0x190000+AY15,   6,    true,    },
            {   9, 3,   5+AX15, 0x1A0000+AY15,   5,    true,    },
            {   9, 6,  11+AX15, 0x1D0000+AY15,   7,    true,    },
            {   9, 1,  17+AX15, 0x200000+AY15,   8,    true,    },

            {   -1,  -1, 0,0,0,    false,   },
        },




    },
};


int visibleFace[] = {
    0, 3, 1,
};



/*
            B/2
           +--+--+--+
           |15|16|17|
           +--+--+--+
           |12|13|14|
           +--+--+--+
           | 9|10|11|
           +--+--+--+
 A/0        C/3        E/5        F/6
+--+--+--+ +--+--+--+ +--+--+--+ +--+--+--+
| 6| 7| 8| |24|25|26| |42|43|44| |51|52|53|
+--+--+--+ +--+--+--+ +--+--+--+ +--+--+--+
| 3| 4| 5| |21|22|23| |39|40|41| |48|49|50|
+--+--+--+ +--+--+--+ +--+--+--+ +--+--+--+
| 0| 1| 2| |18|19|20| |36|37|38| |45|46|47|
+--+--+--+ +--+--+--+ +--+--+--+ +--+--+--+
            D/4
           +--+--+--+
 27 30 33  |33|34|35|
           +--+--+--+
 28 31 34  |30|31|32|
           +--+--+--+
 29 32 35  |27|28|29|
           +--+--+--+
*/



const unsigned char *shapeMarker[] = {
    &marker[0],
    &marker[0],
    &marker[0],
    &marker[0],
    &marker[0],
    &marker[0],
    &marker[0],
    &marker[0],
};


const unsigned char *shapeSetTop[] = {
    // rotation 0
    &topFacets000[0],
    &topFacets001[0],
    &topFacets010[0],
    &topFacets011[0],
    &topFacets100[0],
    &topFacets101[0],
    &topFacets110[0],
    &topFacets111[0],
};

const unsigned char *shapeSetTop2[] = {
    // rotation 0
    &top2Facets000[0],
    &top2Facets001[0],
    &top2Facets010[0],
    &top2Facets011[0],
    &top2Facets100[0],
    &top2Facets101[0],
    &top2Facets110[0],
    &top2Facets111[0],
};

const unsigned char *shapeSetTop3[] = {
    // rotation 0
    &top3Facets000[0],
    &top3Facets001[0],
    &top3Facets010[0],
    &top3Facets011[0],
    &top3Facets100[0],
    &top3Facets101[0],
    &top3Facets110[0],
    &top3Facets111[0],
};

const unsigned char *shapeSetTop45[] = {
    // rotation 0
    &topFacet45_000[0],
    &topFacet45_001[0],
    &topFacet45_010[0],
    &topFacet45_011[0],
    &topFacet45_100[0],
    &topFacet45_101[0],
    &topFacet45_110[0],
    &topFacet45_111[0],
};

const unsigned char *shapeSetFront45[] = {
    // rotation 0
    &frontFacet45_000[0],
    &frontFacet45_001[0],
    &frontFacet45_010[0],
    &frontFacet45_011[0],
    &frontFacet45_100[0],
    &frontFacet45_101[0],
    &frontFacet45_110[0],
    &frontFacet45_111[0],
};


const unsigned char *shapeSetRight[] = {
    &rightFacets000[0],
    &rightFacets001[0],
    &rightFacets010[0],
    &rightFacets011[0],
    &rightFacets100[0],
    &rightFacets101[0],
    &rightFacets110[0],
    &rightFacets111[0],
};

const unsigned char *shapeSetRight2[] = {
    &right2Facets000[0],
    &right2Facets001[0],
    &right2Facets010[0],
    &right2Facets011[0],
    &right2Facets100[0],
    &right2Facets101[0],
    &right2Facets110[0],
    &right2Facets111[0],
};

const unsigned char *shapeSetRight3[] = {
    &right3Facets000[0],
    &right3Facets001[0],
    &right3Facets010[0],
    &right3Facets011[0],
    &right3Facets100[0],
    &right3Facets101[0],
    &right3Facets110[0],
    &right3Facets111[0],
};

const unsigned char *shapeSetLeft[] = {
    &leftFacets000[0],
    &leftFacets001[0],
    &leftFacets010[0],
    &leftFacets011[0],
    &leftFacets100[0],
    &leftFacets101[0],
    &leftFacets110[0],
    &leftFacets111[0],
};

const unsigned char *shapeSetLeft2[] = {
    &left2Facets000[0],
    &left2Facets001[0],
    &left2Facets010[0],
    &left2Facets011[0],
    &left2Facets100[0],
    &left2Facets101[0],
    &left2Facets110[0],
    &left2Facets111[0],
};

const unsigned char *shapeSetLeft3[] = {
    &left3Facets000[0],
    &left3Facets001[0],
    &left3Facets010[0],
    &left3Facets011[0],
    &left3Facets100[0],
    &left3Facets101[0],
    &left3Facets110[0],
    &left3Facets111[0],
};

const unsigned char *shapeBoundary[] = {
    &cubeBoundary[0],
    &cube1Boundary[0],
    &cubeBoundary[0],
    &cubeBoundary[0],
    &cubeBoundary[0],
    &cubeBoundary[0],
    &cubeBoundary[0],
    &cubeBoundary[0],
};



/*
               +---+---+---+  
               |   |   |   |
               +---+---+---+  
               |   |tOP|   |
               +---+---+---+  
               |   |   |   |
               +---+---+---+  

+---+---+---+  +---+---+---+  +---+---+---+  +---+---+---+  
|  0|  1|  2|  |   |   |   |  |   |   |   |  |   |   |   |  
+---+---+---+  +---+---+---+  +---+---+---+  +---+---+---+  
|   | BL|   |  |   | FL|   |  |   |FR |   |  |   | BR|   |  
+---+---+---+  +---+---+---+  +---+---+---+  +---+---+---+  
|   |   |   |  |   |   |   |  |   |   |   |  |   |   |   |  
+---+---+---+  +---+---+---+  +---+---+---+  +---+---+---+  

               +---+---+---+  
               |   |   |   |
               +---+---+---+  
               |   |BOT|   |
               +---+---+---+  
               |   |   |   |
               +---+---+---+
*/

#define FACETX 3               
#define FACETXOFFSET 0
#define FACETXOFFSET2 (FACETXOFFSET  + (FACETX * 3 + 1))
#define FACETXOFFSET3 (FACETXOFFSET2 + (FACETX * 3 + 1))
#define FACETXOFFSET4 (FACETXOFFSET3 + (FACETX * 3 + 1))

#define FACETY 6
#define FACETYOFFSET 0
#define FACETYOFFSET2 (FACETYOFFSET  + (FACETY * 3 + 2))
#define FACETYOFFSET3 (FACETYOFFSET2 + (FACETY * 3 + 2))


#define FACETX2 5
#define FACETY2 5

#define FACETXBLOFFSET 5
#define FACETXTOPOFFSET 12
#define FACETXFLOFFSET 0
#define FACETXBOTOFFSET FACETXTOPOFFSET
#define FACETXFROFFSET 20
#define FACETXBROFFSET 16

#define FACETYBLOFFSET 12
#define FACETYTOPOFFSET 6
#define FACETYFLOFFSET 12
#define FACETYBOTOFFSET 24
#define FACETYFROFFSET 12
#define FACETYBROFFSET 12

const int facetX[] = {

    // BL
    0*FACETX2 + FACETXBLOFFSET, 1*FACETX2 + FACETXBLOFFSET, 2*FACETX2 + FACETXBLOFFSET,
    0*FACETX2 + FACETXBLOFFSET, 1*FACETX2 + FACETXBLOFFSET, 2*FACETX2 + FACETXBLOFFSET,
    0*FACETX2 + FACETXBLOFFSET, 1*FACETX2 + FACETXBLOFFSET, 2*FACETX2 + FACETXBLOFFSET,

    //TOP
    0*FACETX2 + FACETXTOPOFFSET, 1*FACETX2 + FACETXTOPOFFSET, 2*FACETX2 + FACETXTOPOFFSET,
    0*FACETX2 + FACETXTOPOFFSET, 1*FACETX2 + FACETXTOPOFFSET, 2*FACETX2 + FACETXTOPOFFSET,
    0*FACETX2 + FACETXTOPOFFSET, 1*FACETX2 + FACETXTOPOFFSET, 2*FACETX2 + FACETXTOPOFFSET,

    //FL
    0*FACETX2 + FACETXFLOFFSET ,1*FACETX2 + FACETXFLOFFSET, 2*FACETX2 + FACETXFLOFFSET,
    0*FACETX2 + FACETXFLOFFSET ,1*FACETX2 + FACETXFLOFFSET, 2*FACETX2 + FACETXFLOFFSET,
    0*FACETX2 + FACETXFLOFFSET ,1*FACETX2 + FACETXFLOFFSET, 2*FACETX2 + FACETXFLOFFSET,

    //BOT
    0*FACETX2 + FACETXBOTOFFSET, 1*FACETX2 + FACETXBOTOFFSET, 2*FACETX2 + FACETXBOTOFFSET,
    0*FACETX2 + FACETXBOTOFFSET, 1*FACETX2 + FACETXBOTOFFSET, 2*FACETX2 + FACETXBOTOFFSET,
    0*FACETX2 + FACETXBOTOFFSET, 1*FACETX2 + FACETXBOTOFFSET, 2*FACETX2 + FACETXBOTOFFSET,

    //FR
    0*FACETX2 + FACETXFROFFSET, 1*FACETX2 + FACETXFROFFSET, 2*FACETX2 + FACETXFROFFSET,
    0*FACETX2 + FACETXFROFFSET, 1*FACETX2 + FACETXFROFFSET, 2*FACETX2 + FACETXFROFFSET,
    0*FACETX2 + FACETXFROFFSET, 1*FACETX2 + FACETXFROFFSET, 2*FACETX2 + FACETXFROFFSET,

    // BR
    0*FACETX2 + FACETXBROFFSET, 1*FACETX2 + FACETXBROFFSET, 2*FACETX2 + FACETXBROFFSET,
    0*FACETX2 + FACETXBROFFSET, 1*FACETX2 + FACETXBROFFSET, 2*FACETX2 + FACETXBROFFSET,
    0*FACETX2 + FACETXBROFFSET, 1*FACETX2 + FACETXBROFFSET, 2*FACETX2 + FACETXBROFFSET,

    -1,
};

const int facetY[] = {

    0 * FACETY2 + FACETYBLOFFSET,  0 * FACETY2 + FACETYBLOFFSET, 0 * FACETY2 + FACETYBLOFFSET,
    1 * FACETY2 + FACETYBLOFFSET,  1 * FACETY2 + FACETYBLOFFSET, 1 * FACETY2 + FACETYBLOFFSET,
    2 * FACETY2 + FACETYBLOFFSET,  2 * FACETY2 + FACETYBLOFFSET, 2 * FACETY2 + FACETYBLOFFSET,
    0 * FACETY2 + FACETYTOPOFFSET,  0 * FACETY2 + FACETYTOPOFFSET,  0 * FACETY2 + FACETYTOPOFFSET,
    1 * FACETY2 + FACETYTOPOFFSET,  1 * FACETY2 + FACETYTOPOFFSET,  1 * FACETY2 + FACETYTOPOFFSET,
    2 * FACETY2 + FACETYTOPOFFSET,  2 * FACETY2 + FACETYTOPOFFSET,  2 * FACETY2 + FACETYTOPOFFSET,
    0 * FACETY2 + FACETYFLOFFSET,  0 * FACETY2 + FACETYFLOFFSET, 0 * FACETY2 + FACETYFLOFFSET,
    1 * FACETY2 + FACETYFLOFFSET,  1 * FACETY2 + FACETYFLOFFSET, 1 * FACETY2 + FACETYFLOFFSET,
    2 * FACETY2 + FACETYFLOFFSET,  2 * FACETY2 + FACETYFLOFFSET, 2 * FACETY2 + FACETYFLOFFSET,
    0 * FACETY2 + FACETYBOTOFFSET, 0 * FACETY2 + FACETYBOTOFFSET, 0 * FACETY2 + FACETYBOTOFFSET,
    1 * FACETY2 + FACETYBOTOFFSET, 1 * FACETY2 + FACETYBOTOFFSET, 1 * FACETY2 + FACETYBOTOFFSET,
    2 * FACETY2 + FACETYBOTOFFSET, 2 * FACETY2 + FACETYBOTOFFSET, 2 * FACETY2 + FACETYBOTOFFSET,
    0 * FACETY2 + FACETYFROFFSET,  0 * FACETY2 + FACETYFROFFSET, 0 * FACETY2 + FACETYFROFFSET,
    1 * FACETY2 + FACETYFROFFSET,  1 * FACETY2 + FACETYFROFFSET, 1 * FACETY2 + FACETYFROFFSET,
    2 * FACETY2 + FACETYFROFFSET,  2 * FACETY2 + FACETYFROFFSET, 2 * FACETY2 + FACETYFROFFSET,
    0 * FACETY2 + FACETYBROFFSET,  0 * FACETY2 + FACETYBROFFSET, 0 * FACETY2 + FACETYBROFFSET,
    1 * FACETY2 + FACETYBROFFSET,  1 * FACETY2 + FACETYBROFFSET, 1 * FACETY2 + FACETYBROFFSET,
    2 * FACETY2 + FACETYBROFFSET,  2 * FACETY2 + FACETYBROFFSET, 2 * FACETY2 + FACETYBROFFSET,
};


const int facetEndX[] = {

    // BL
    0*FACETX  + FACETXOFFSET, 1*FACETX  + FACETXOFFSET, 2*FACETX  + FACETXOFFSET,
    0*FACETX  + FACETXOFFSET, 1*FACETX  + FACETXOFFSET, 2*FACETX  + FACETXOFFSET,
    0*FACETX  + FACETXOFFSET, 1*FACETX  + FACETXOFFSET, 2*FACETX  + FACETXOFFSET,

    //TOP
    0*FACETX  + FACETXOFFSET2, 1*FACETX  + FACETXOFFSET2, 2*FACETX  + FACETXOFFSET2,
    0*FACETX  + FACETXOFFSET2, 1*FACETX  + FACETXOFFSET2, 2*FACETX  + FACETXOFFSET2,
    0*FACETX  + FACETXOFFSET2, 1*FACETX  + FACETXOFFSET2, 2*FACETX  + FACETXOFFSET2,

    //FL
    0*FACETX  + FACETXOFFSET2 ,1*FACETX  + FACETXOFFSET2, 2*FACETX  + FACETXOFFSET2,
    0*FACETX  + FACETXOFFSET2 ,1*FACETX  + FACETXOFFSET2, 2*FACETX  + FACETXOFFSET2,
    0*FACETX  + FACETXOFFSET2 ,1*FACETX  + FACETXOFFSET2, 2*FACETX  + FACETXOFFSET2,

    //BOT
    0*FACETX  + FACETXOFFSET2, 1*FACETX  + FACETXOFFSET2, 2*FACETX  + FACETXOFFSET2,
    0*FACETX  + FACETXOFFSET2, 1*FACETX  + FACETXOFFSET2, 2*FACETX  + FACETXOFFSET2,
    0*FACETX  + FACETXOFFSET2, 1*FACETX  + FACETXOFFSET2, 2*FACETX  + FACETXOFFSET2,

    //FR
    0*FACETX  + FACETXOFFSET3, 1*FACETX  + FACETXOFFSET3, 2*FACETX  + FACETXOFFSET3,
    0*FACETX  + FACETXOFFSET3, 1*FACETX  + FACETXOFFSET3, 2*FACETX  + FACETXOFFSET3,
    0*FACETX  + FACETXOFFSET3, 1*FACETX  + FACETXOFFSET3, 2*FACETX  + FACETXOFFSET3,

    // BR
    0*FACETX  + FACETXOFFSET4, 1*FACETX  + FACETXOFFSET4, 2*FACETX  + FACETXOFFSET4,
    0*FACETX  + FACETXOFFSET4, 1*FACETX  + FACETXOFFSET4, 2*FACETX  + FACETXOFFSET4,
    0*FACETX  + FACETXOFFSET4, 1*FACETX  + FACETXOFFSET4, 2*FACETX  + FACETXOFFSET4,

    -1,
};

const int facetEndY[] = {

    0 * FACETY  + FACETYOFFSET2, 0 * FACETY  + FACETYOFFSET2, 0 * FACETY  + FACETYOFFSET2,
    1 * FACETY  + FACETYOFFSET2, 1 * FACETY  + FACETYOFFSET2, 1 * FACETY  + FACETYOFFSET2,
    2 * FACETY  + FACETYOFFSET2, 2 * FACETY  + FACETYOFFSET2, 2 * FACETY  + FACETYOFFSET2,

    0 * FACETY  + FACETYOFFSET, 0 * FACETY  + FACETYOFFSET, 0 * FACETY  + FACETYOFFSET,
    1 * FACETY  + FACETYOFFSET, 1 * FACETY  + FACETYOFFSET, 1 * FACETY  + FACETYOFFSET,
    2 * FACETY  + FACETYOFFSET, 2 * FACETY  + FACETYOFFSET, 2 * FACETY  + FACETYOFFSET,

    0 * FACETY  + FACETYOFFSET2, 0 * FACETY  + FACETYOFFSET2, 0 * FACETY  + FACETYOFFSET2,
    1 * FACETY  + FACETYOFFSET2, 1 * FACETY  + FACETYOFFSET2, 1 * FACETY  + FACETYOFFSET2,
    2 * FACETY  + FACETYOFFSET2, 2 * FACETY  + FACETYOFFSET2, 2 * FACETY  + FACETYOFFSET2,

    0 * FACETY  + FACETYOFFSET3, 0 * FACETY  + FACETYOFFSET3, 0 * FACETY  + FACETYOFFSET3,
    1 * FACETY  + FACETYOFFSET3, 1 * FACETY  + FACETYOFFSET3, 1 * FACETY  + FACETYOFFSET3,
    2 * FACETY  + FACETYOFFSET3, 2 * FACETY  + FACETYOFFSET3, 2 * FACETY  + FACETYOFFSET3,

    0 * FACETY  + FACETYOFFSET2, 0 * FACETY  + FACETYOFFSET2, 0 * FACETY  + FACETYOFFSET2,
    1 * FACETY  + FACETYOFFSET2, 1 * FACETY  + FACETYOFFSET2, 1 * FACETY  + FACETYOFFSET2,
    2 * FACETY  + FACETYOFFSET2, 2 * FACETY  + FACETYOFFSET2, 2 * FACETY  + FACETYOFFSET2,

    0 * FACETY  + FACETYOFFSET2, 0 * FACETY  + FACETYOFFSET2, 0 * FACETY  + FACETYOFFSET2,
    1 * FACETY  + FACETYOFFSET2, 1 * FACETY  + FACETYOFFSET2, 1 * FACETY  + FACETYOFFSET2,
    2 * FACETY  + FACETYOFFSET2, 2 * FACETY  + FACETYOFFSET2, 2 * FACETY  + FACETYOFFSET2,
};


#define SMALLFACET(a,b,c) \
1,18,0,0, \
a & XXX_____ \
b & XXX_____ \
c & XXX_____ \
a & XXX_____ \
b & XXX_____ \
c & XXX_____ \
a & XXX_____ \
b & XXX_____ \
c & XXX_____ \
a & XXX_____ \
b & XXX_____ \
c & XXX_____ \
a & XXX_____ \
b & XXX_____ \
c & XXX_____ \
a & XXX_____ \
b & XXX_____ \
c & XXX_____

const unsigned char facetColour0[] = {
    SMALLFACET(0,0,0)
};
const unsigned char facetColour1[] = {
    SMALLFACET(0xFF,0,0)
};
const unsigned char facetColour2[] = {
    SMALLFACET(0,0xFF,0)
};
const unsigned char facetColour3[] = {
    SMALLFACET(0xFF,0xFF,0)
};
const unsigned char facetColour4[] = {
    SMALLFACET(0,0,0xFF)
};
const unsigned char facetColour5[] = {
    SMALLFACET(0xFF,0,0xFF)
};
const unsigned char facetColour6[] = {
    SMALLFACET(0,0xFF,0xFF)
};
const unsigned char facetColour7[] = {
    SMALLFACET(0xFF,0xFF,0xFF)
};


const unsigned char *shapeSetFacet[8] = {
    facetColour0,
    facetColour1,
    facetColour2,
    facetColour3,
    facetColour4,
    facetColour5,
    facetColour6,
    facetColour7,
};



int rr = 0;

void drawSoftwareSprites() {


    if (drawMode == 0) {
        drawOverviewSoftwareSprites();
        return;
    }



    rr = rotateTop[fLayer];
//    if (JOY0_FIRE || fLayer == 2)
//        rr = rotateTop[0];

    // rr = 14;


    struct facet *f = &shapeDef[0][rr][fno++];

    // no more facets --> finished drawing
    if (f->face < 0) {

        fno = 0;


        if (++fLayer > 2) {
            fLayer = 0;
            finished = true;


            if (highlightLayer) {
                highlightLayer--;
                showHighlight=  true;
            }
            else
                showHighlight = false;


            if (changedLayer) {
                changedLayer--;
            }

            for (int l = 0; l < 3; l++) {

                if (rotateSpeed[l])
                    rotateSpeed[l]--;
    
                if (!rotateSpeed[l]) {

                    rotateSpeed[l] = 1;
                    rotateTop[l]+= direct[l];
                    rotateTop[l] &= 15;

                    if (!(rotateTop[l] & 3))
                        direct[l] = 0;
                }

            }
        }


        return;

    }


    const unsigned char **shape = shapeSetTop;
    switch (f->face) {
    case 0: shape = shapeSetTop;
        break;
    case 1: shape = shapeSetLeft;
        break;
    case 2: shape = shapeSetRight;
        break;
    case 3: shape = shapeSetTop45;
        break;
    case 4: shape = shapeSetFront45;
        break;
    case 5: shape = shapeSetRight2;
        break;
    case 6: shape = shapeSetLeft2;
        break;
    case 7: shape = shapeSetTop2;
        break;
    case 8: shape = shapeBoundary;
        break;
    case 9: shape = shapeSetTop3;
        break;
    case 10: shape = shapeSetLeft3;
        break;
    case 11: shape = shapeSetRight3;
        break;
    case 12: shape = shapeMarker;
        break;
    }

    #if MARKER

    for (int m = 0; m < 2; m++) {

        if (m)
            shape = shapeMarker;
    #endif


    int theColour = f->colour;
    if (showHighlight && fLayer == controlledLayer ) //&& !(highlightLayer & 1))
        if (!(highlightLayer & 1))
            theColour = 0;
        // else   
        //      theColour = 0;

    if (!f->topOnly || (fLayer == 2 && f->topOnly))
        drawBitmap(shape[theColour],
            ((f->x << 14) & 0xFFFFC000) + 0x00014000,
            ((((118+2 - (fLayer * 13)) << 16) + (f->y)))  * 3,
            true);

    #if MARKER
    }
    #endif




  
}



void GameVerticalBlank() {
 

    if (finished) {

        if (swap) {
            drawMode ^= 1;
            fLayer = 0;
            fno = 0;
            facetIndex = 0;
            swap = false;
        }


        pfBuffer ^= 1;
        Scroll();
        drawScreen();
        finished = false;
    }

    HandleJoystick();

    setDisplayPalette();

    frameCounter++;
    frameToggler++;

    InitGameDatastreams();

}




#define ROW_MAXIMUM 23

char boardRow;
unsigned char boardCol;

int changeAmoebaToBoulder;

void SetupBoard() {

    if (frameCounter > gameSpeed) {

        lastDripFree = dripFree;
        dripFree = true;

        frameCounter = 0;
        toggler++;

        boardCol = -1;
        boardRow = ROW_MAXIMUM;

        changeAmoebaToBoulder = amoebaCounter;
        amoebaCounter = 0;

        lastAmoebaGrew = amoebaGrew;
        amoebaGrew = 0;

        gameSchedule = SCHEDULE_PROCESSBOARD;

    }
}



void InitGameBuffers() {
    
    // set the Jump Datastream so each entry runs the NORMAL KERNEL by default
    // init Jump Datastream
    for (int i=0; i < _ARENA_SCANLINES; i++)
        RAM_SINT[(_BUF_JUMP1 / 2) + i] = _NORMAL_KERNEL;
    RAM_SINT[ _BUF_JUMP1_EXIT / 2 ] = _EXIT_KERNEL;
}



void GameScheduleProcessBoardRow() {

    if (!finished)
        drawSoftwareSprites();

}




// EOF
