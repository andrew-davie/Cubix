//==============================================================================
// CDFJChess by Andrew Davie
// demo Chessboard Display
// derived from  Collect3 ARM routines by Darrell Spice, Jr.
//==============================================================================



//==============================================================================
// Includes
//--------------------------------------
//  defines_cdfj.h
//      defines and functions for CDFJ coprocessor
//  defines_from_dasm_for_c.h
//      auto-generated by the make file, it contains values from the 6507 code
//  defines.h
//      defines to make the code easier to read
//==============================================================================

#include <stdbool.h>

#include "defines_cdfj.h"
#include "defines_from_dasm_for_c.h"
#include "defines.h"

#include "main.h"
#include "bitpatterns.h"

#include "characterset.h"
#include "logo.h"
#include "attribute.h"
#include "bitshapes.h"
#include "drawplayer.h"
#include "overlay.h"
#include "drawscreen.h"
#include "cavedata.h"
#include "sound.h"
#include "movePlayer.h"
#include "drawBitmap.h"


#define DIGIT_SIZE 18           /* displayed lines */
#define DIGIT_SIZE_ROLLER 24        /* stored lines - rolling with spaces! */


#define DIGIT_DOGE   (11 * DIGIT_SIZE_ROLLER)
#define DIGIT_TIME      (12 * DIGIT_SIZE_ROLLER)
#define DIGIT_SPACE     (13 * DIGIT_SIZE_ROLLER)
#define DIGIT_LIVES     (14 * DIGIT_SIZE_ROLLER)
#define DIGIT_CAVE      (15 * DIGIT_SIZE_ROLLER)
#define DIGIT_LEVEL     (16 * DIGIT_SIZE_ROLLER)
#define DIGIT_DOGE_L    (17 * DIGIT_SIZE_ROLLER)

#define FLASH_DEAD 0x4F


////////////////////////////////////////////////////////////////////////////////
// CONFIGURABLE UX

#define IDLE_TIME          500     /* cycle time in game-over state between Overview/Normal display */
#define SPARKLE            100     /* # frames to sparkle BG on extra life */
#define EXPAND_SPEED         6     /* Amoeba expansion rate larger = faster, expansion speed for amoeba (/128)) */
#define ROLL_SPEED           3     /* score digit rolling. Factor of DIGIT_SIZE_ROLLER only (1/2/3/4/6/8/12) */
#define SCOREVISIBLETIME   130     /* # frames to show changed scoreline item before reverting to defaults */
#define DEAD_RESTART        20     /* # frames to hold trigger after loss of life, to start next life */

#define MAX_PEBBLES        100     /* # random pebbles to put in dirt */

    // Delays on RESET and SELECT are to allow non-ambiguous press of SELECT+RESET for suicide

#define RESET_DELAY         20     /* # frames to hold RESET before it is detected */
#define SELECT_DELAY        10     /* # frames to hold SELECT before it is detected */

////////////////////////////////////////////////////////////////////////////////

int pfBuffer;
int cubePtr;

int parallax;
bool finished = true;

int drillHeight;

int scoreLineCurrent[10];
int scoreLineNew[10];
int water, lava;
unsigned char *lastWater;
unsigned char bgPalette[24];

#define SPACESHIPS 19
int spaceshipY[SPACESHIPS];
//int spaceshipAccel[SPACESHIPS];
int spaceshipWait[SPACESHIPS];
int spaceshipMode[SPACESHIPS];
int spaceshipX[SPACESHIPS];
int spaceshipVar[SPACESHIPS];
int spaceshipSquare[SPACESHIPS];
int spaceshipRightShape[SPACESHIPS];
int spaceshipLeftShape[SPACESHIPS];
int spaceshipTopShape[SPACESHIPS];

//int spaceshipTargetX[SPACESHIPS];
//int spaceshipVar[SPACESHIPS];
unsigned const char *spaceShipShape[SPACESHIPS];

int tuneIndex;
int millingTime;                // negative = expired


int scoreCycle;

int doge;
int time;
int level;
int terminalDelay;

bool dripFree;
bool lastDripFree;

extern int caveFlags;

#if ENABLE_SHAKE
int shakeX, shakeY;
int shakeTime;
#endif

#if ENABLE_PARALLAX
#define CHAR_SIZE (PIECE_DEPTH + 9 + 9)

unsigned char parallaxBlank[CHAR_SIZE];
unsigned char charDust3[CHAR_SIZE];

#endif


bool thisFrame[2][40];


int fLayer = 0;
int layer = 0;
int initSpeed[3] = { 1,3,5};
int direct[3] = {1,-1,1};
int fno = 0;
int rotateTop[] = {1,1,1};
int rotateSpeed[] = {1,1,1};




void setAnimation(int animID);



struct Animation AnimIdx[TYPE_MAX];

//unsigned char AnimIdx[TYPE_MAX];


//==============================================================================
// Variables
//--------------------------------------
// Within C there are rules about where a variable can be seen based on where it
// is defined.  This is known as scope:
//      https://www.tutorialspoint.com/cprogramming/c_scope_rules.htm
//
// Very brief summary of scope:
//
//  Global Variable - variables defined outside of a function can be used by ANY function.
//  Local Variable - variables defined inside a function can be use by ONLY that function.
//
// The ARM used in the Harmony/Melody does not support floating point values, so
// we can only use data types of char and int. These types can be modified with
// unsigned and/or short to change the range of values that can be represented.
//
// signed char        =  8 bit, 1 byte,  range is           -128 to           127
// char               =  8 bit, 1 byte,  range is              0 to           255
// unsigned char      =  8 bit, 1 byte,  range is              0 to           255
// short int          = 16 bit, 2 bytes, range is        -32,768 to        32,767
// unsigned short int = 16 bit, 2 bytes, range is              0 to        65,535
// int                = 32 bit, 4 bytes, range is -2,147,483,648 to 2,147,483,647
// unsigned int       = 32 bit, 4 bytes, range is              0 to 4,294,967,295
//
// NOTE: variables of int and unsigned int result in smaller/faster code, but
// are not always practical to use due to limited amount of RAM available.
//
// When referencing data defined in the 6507 code:
//      BYTE = char (range -128 to 127)
//      BYTE = unsigned char (range 0 to 255)
//      WORD = short int (range -32768 to 32767)
//      WORD = unsigned short int (range 0 to 65535)
//
// NOTE: WORD data that will be used by the ARM must be on 2 byte boundaries.
//
//==============================================================================


// enum FLAG {
//     FLAG_THISFRAME = 0x80,
// };



unsigned char is_7800;  // 0 = 2600, non-zero = 7800

// Image Data

//const unsigned char *arena_increments =(unsigned char *)_ARENA_INCREMENTS;

unsigned char mm_tv_type = 0;  // 0 = NTSC, 1 = PAL, 2 = SECAM

enum Direction rockfordDirection = RIGHT;

int frameAdjustX;
int frameAdjustY;
int frameAdjustSmallX;
int frameAdjustSmallY;

bool amoebaAudio;
bool exitTrigger;
int diamondGrabTime;


// Timers

int flashTime;                  // frames for initial HOLD on BG colour flashing

int idleTimer;

unsigned int sparkleTimer;

// Scoring

int actualScore;
int partialScore;
int forceScoreDraw;





bool exitMode;

unsigned char ScorePtr[6];

unsigned int frameCounter;
unsigned int frameToggler;
unsigned int gameSpeed;
unsigned int toggler;


#define DISPLAY_NORMAL 0

#define DISPLAY_OVERVIEW 1
#define DISPLAY_NONE 2

unsigned char displayMode, lastDisplayMode;

//unsigned char joy0FireBuffer = 0xFF;
unsigned int triggerPressCounter = 0;
unsigned int dogeCollected;

//#define PUSH_DELAY 10
#define DELAY_AFTER_PUSH 3
unsigned int pushCounter;
unsigned int halt;


// unsigned int uncoverCount;
int rockfordX, rockfordY;
bool rockfordDead;
int lives;

int selectResetDelay;;
int resetDelay = 0;
int selectDelay = 0;

int diamondValue;
int extraDogeCoinValue;

int amoebaCounter = 0;
int amoebaGrew = 1;
int lastAmoebaGrew = 0;
int cave = 0;
bool caveCompleted;
unsigned char bufferedSWCHA = 0xFF;

unsigned int maxScrollXSpeed;


// COMPILE-TIME REVERSE BITS IN BYTE
#define RVS(a) ( \
      ((((a) >> 0) & 1) << 7) \
    | ((((a) >> 1) & 1) << 6) \
    | ((((a) >> 2) & 1) << 5) \
    | ((((a) >> 3) & 1) << 4) \
    | ((((a) >> 4) & 1) << 3) \
    | ((((a) >> 5) & 1) << 2) \
    | ((((a) >> 6) & 1) << 1) \
    | ((((a) >> 7) & 1) << 0) \
    )

#define P0(a) RVS(a)
#define P1(a) P0(a), P0(a+1)
#define P2(a) P1(a), P1(a+2)
#define P3(a) P2(a), P2(a+4)
#define P4(a) P3(a), P3(a+8)
#define P5(a) P4(a), P4(a+16)
#define P6(a) P5(a), P5(a+32)
#define P7(a) P6(a), P6(a+64)
#define P8(a) P7(a), P7(a+128)

// Want to call RVS(n) for 0-255 values. The weird #defines above aloow a single-call
// It's effectively a recursive power-of-two call of the base RVS macro

const unsigned char BitRev[] = {
    P8(0),
};


int scrollX;                // 16.16 PF pixels
int scrollY;                // 16.16 TRI pixel lines



int scrollSpeed = 0, scrollYSpeed = 0;
int targetScrollSpeed = 0, targetYScrollSpeed = 0;




//==============================================================================
// Contstants
//--------------------------------------
// Contstants do not change their value at runtime, so are stored in ROM.
//
// WARNING: If the const is left off the values will be stored in ROM, but then
// copied into RAM when the Harmony/Melody is turned on.
//==============================================================================


const unsigned char NTSCtoPAL[16] =
{
    // SeaGtGruff's conversion values from this post at AtariAge:
    // https://atariage.com/forums/topic/165424-modify-colour-palette/?do=findComment&comment=2043124
    0x00, 0x20, 0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0,
    0xd0, 0xb0, 0x90, 0x70, 0x50, 0x30, 0x30, 0x20
};

const unsigned char NTSCtoSECAM[16] =
{
    0x0e,   // 0 = white            e = white
    0x0c,   // 1 = yellow           c = yellow
    0x0c,   // 2 = yellowish orange c = yellow
    0x04,   // 3 = reddish orange   4 = red
    0x04,   // 4 = red              4 = red
    0x06,   // 5 = reddish purple   6 = purple
    0x06,   // 6 = purple           6 = purple
    0x06,   // 7 = bluish purple    6 = purple
    0x02,   // 8 = blue             2 = blue
    0x02,   // 9 = blue             2 = blue
    0x0a,   // a = bluish cyan      a = cyan
    0x0a,   // b = cyan             a = cyan
    0x08,   // c = green            8 = green
    0x08,   // d = green            8 = green
    0x08,   // e = olive green      8 = green
    0x0c    // f = brown            c = yellow
};

enum DIR {
    DIR_UP = 1,
    DIR_DOWN = 2,
    DIR_LEFT = 4,
    DIR_RIGHT = 8,
};

const int xInc[] = {

        // RLDU
    0,  // 0000
    0,  // 0001
    0,  // 0010
    0,  // 0011
    -1, // 0100
    -1, // 0101
    -1, // 0110
    0,  // 0111
    1,  // 1000
    1,  // 1001
    1,  // 1010
    0,  // 1011
    0,  // 1100
    0,  // 1101
    0,  // 1110
    0,  // 1111
};

const int yInc[] = {

        // RLDU
    0,  // 0000
    -1, // 0001
    1,  // 0010
    0,  // 0011
    0,  // 0100
    -1, // 0101
    1,  // 0110
    0,  // 0111
    0,  // 1000
    -1, // 1001
    1,  // 1010
    0,  // 1011
    0,  // 1100
    0,  // 1101
    0,  // 1110
    0,  // 1111
};


// Function Prototypes

unsigned char ColourConvert(unsigned char);
void GameOverscan();
void GameVerticalBlank();
void InitGameBuffers();
void Initialize();
void drawScreen();
//void SplashOverScan();
//void SplashVerticalBlank();
void Scheduler();
void SetupBoard();

// extern void DecodeCave(const unsigned char *cave);
extern bool DecodeExplicitData();

void drawOverviewScreen();
unsigned int getRandom32();

extern int RandSeed1, RandSeed2;
extern void NextRandom(int *RandSeed1, int *RandSeed2);




//==============================================================================
// Function Definitions
//--------------------------------------
// main() is the initial function called when running C code. Main is defined as
// returning an int value. You could change it to void and it will still work;
// however, it will introduce compile time warnings, and unlike using void for
// other functions using void for main() will not save any ROM.
//==============================================================================


void setFlash(int colour, int time) {
    ARENA_COLOR = colour;
    flashTime = time;
}



unsigned char ColourConvert(unsigned char color) {

    if (mm_tv_type == PAL) {
        return NTSCtoPAL[color>>4] +    // convert chroma value
               (color & 0x0f);          // retain luma value
    }

    else if (mm_tv_type == SECAM) {
        return color < 2 ? 0 : NTSCtoSECAM[color>>4];
    }

    else
        return color;
}



enum SCHEDULE {
    SCHEDULE_START,
    SCHEDULE_PROCESSBOARD,
    SCHEDULE_UNPACK_CAVE,
};

enum SCHEDULE gameSchedule = SCHEDULE_START;

const int cnoNext[] = { 1, 2, 0 };


int main() {

    // main() is called when the 6507 code writes to CALLFN.
    // The 6507 code sets the value of RUN_FUNC.
    
    switch (RUN_FUNC)
    {
    case _FN_INIT:
        Initialize();
        break;

    case _FN_GAME_OS:
        GameOverscan();
        break;

    case _FN_GAME_VB:
        GameVerticalBlank();
        break;

    case _FN_GAME_IDLE:
        Scheduler();
        break;
    }
    
    return 0;
}




void addScore(int score) {

    actualScore += score;
    scoreCycle = 1;
    forceScoreDraw = SCOREVISIBLETIME;

    partialScore += score;
    while (partialScore >= 500) {
        partialScore -= 500;
        if (lives < 9) {

            lives++;
            sparkleTimer = SPARKLE;
            scoreCycle = 1;
            AddAudio(SFX_EXTRA);
        }
    }
}

#if ENABLE_OVERLAY
const unsigned char (*overlayWord)[5];
#endif

void resetTracking() {

    // Set scroll track

    scrollX =(rockfordX - (HALFWAYX>>2)) << 16;
    scrollY = ((rockfordY - 4) * TRILINES) << 16;

    scrollSpeed = 0;
    targetScrollSpeed = 0;
    scrollYSpeed = 0;
    targetYScrollSpeed = 0;
}



void setColours() {

    unsigned char i;
    unsigned char colour[3];

    for (i = 0; i < 3; i++)
        colour[i] = ColourConvert(caveList[cave].caveColour[0][i]);

/*    if (attractCounter > ATTRACT_TRIGGER) {
        unsigned char colbase = getRandom32();
        for (i = 0; i < 3; i++)
            colour[i] = ((colour[i] ^ colbase ) + i * 0x50) & 0xF2;
        ARENA_COLOR = colbase & 0xF0;
    }
*/

    unsigned char scorecol = lives? 0x29 : 0x49;
    unsigned char bgCol = flashTime ? ARENA_COLOR : 0;

    i = 0;
    // if (displayMode == DISPLAY_NORMAL)
    //     while (i < SCORE_SCANLINES) {
    //         RAM[_BUF_COLUPF + i] = ColourConvert(scorecol);
    //         RAM[_BUF_COLUBK + i] = bgCol;
            
    //         scorecol -= (i + (i>>1))>>4;
    //         i++;
    //     }

    unsigned char cno = 0;
    while (i < _ARENA_SCANLINES) {
        RAM[_BUF_COLUPF + i] = ColourConvert(colour[cno]);
        RAM[_BUF_COLUBK + i] = bgCol;
        cno = cnoNext[cno];
        i++;
    }


}

bool hasTopFace[] = {

    false, false, false, false,
    false, false, false, false,
    false, false, true, true,
    true, true, true, true,
    true, true, true,

};

bool hasRightFace[] = {

    false, true, false, true,
    true, false, true, false,
    true, true, false, false,
    false, false, false, true,
    false, true, true,
};

bool hasLeftFace[] = {

    true, false, true, false,
    true, true, false, true,
    false, true, false, false,
    false, true, false, false,
    true, false, true,
};




void InitGameX() {

    for (int i = 0; i < 2; i++)
        thisFrame[0][i] = thisFrame[1][i] = false;

#define SPCX 4
#define SPCY 1




    const int ssx[] = {

        4, 24,
        9, 19,
        14,

        4, 24,
        9, 19,
        14,

        14,
        9,19,
        4, 14, 24,
        9,19,
        14,
    };

    const int ssy[] = {

        0x190000+0x150000, 0x190000+0x150000,
        0x1E0000+0x150000, 0x1E0000+0x150000,
        0x230000+0x150000,

        0x190000+0x80000, 0x190000+0x80000,
        0x1E0000+0x80000, 0x1E0000+0x80000,
        0x230000+0x80000,

        0xA0000,
        0xF0000, 0xF0000,
        0x140000, 0x140000, 0x140000,
        0x190000, 0x190000,
        0x1E0000,
     };


    for (int sno = 0; sno < SPACESHIPS; sno++) {
//        spaceshipY[sno] = -((120 + (getRandom32() & 0x20)) <<16); //16 << 16;
        // spaceshipAccel[sno] = 0;
        spaceshipWait[sno] = 0;
        spaceshipMode[sno] = 0;
        spaceshipVar[sno] = 0;
        spaceshipSquare[sno] = sno;
        
//        spaceshipX[sno] = 5 << 14; //(((getRandom32() & 0xFF) >> 8) * 160) << 14;

        spaceshipY[sno] = ((ssy[sno])); // << 16) * 3;
        spaceshipX[sno] = ssx[sno] << 14;

        do
            spaceshipRightShape[sno] = getRandom32() & 7;
        while (spaceshipRightShape[sno] < 2);
        do
            spaceshipLeftShape[sno] = getRandom32() & 7;
        while (spaceshipLeftShape[sno] < 2);
        do
            spaceshipTopShape[sno] = getRandom32() & 7;
        while (spaceshipTopShape[sno] < 2);
//        spaceshipTopShape[sno] = sno & 7;

        // spaceshipTargetX[sno] = 5 << 16;

        // if (getRandom32() & 1)
        //     spaceShipShape[sno] = &eroShip[0];
        // else
        //     spaceShipShape[sno] = &eroShip2[0];


    }

    drillHeight = 1;



#if ENABLE_PARALLAX

    // setup RAM chars to contain correct overview-mode char defs
    for (int i = 0; i < CHAR_SIZE; i++) {
        parallaxBlank[i] = 0;
    }

#endif





    dripFree = true;
    water = 0;
    lava = 0;
    lastWater = 0;

#if ENABLE_SHAKE
    shakeTime = 0;
    shakeX = 0;
    shakeY = 0;
#endif

extern int looneyIndex;
extern int looneyY;

    looneyIndex = 0;
    looneyY = 0x400;

extern int radius;
extern int rinc;

    radius = 0;
    rinc = 100;

    rockfordX = 1;
    rockfordY = 19;
    // rockfordY = 12;
    playerX = (rockfordX * 4) << 16;
    playerY = (rockfordY * PIECE_DEPTH/3) << 16;

    playerSpeedX = 20000;
    playerSpeedY = 30000;


    exitTrigger = false;
    exitMode = false;
    idleTimer = 0;
    terminalDelay = 0;

    tuneIndex = -1;
    amoebaAudio = false;
    gameSchedule = SCHEDULE_START;

//rockfordX = 20; //tmp
//rockfordY = 10; //tmp

    
    KillRepeatingAudio();

    pushCounter = 0;
    halt = 0;
    sparkleTimer = 0;

    amoebaGrew = 1;
    lastDisplayMode = DISPLAY_NONE;


    bufferedSWCHA = 0xFF;

//    joy0FireBuffer = 0xFF;

    dogeCollected = 0;

    scrollSpeed = 0;
    scrollYSpeed = 0;
    rockfordDead = false;

    gameSpeed = GAMESPEED * DEBUG_SLOWDOWN; //12;
    frameCounter = gameSpeed;               // force initial 

    setFlash(0,0);



    scrollX = 38 << 14; //((((getRandom32() & 0xFF) * 38) >> 8) + 1) << 16;
    scrollY = 20 << 16; //((((getRandom32() & 0xFF) * 20) >> 8) + 1) << 16;


    InitAudio();
    AddAudio(SFX_TICK);


#if ENABLE_OVERLAY

    if (overlayWord != overlayBoulderDash) {
        overlayWord = overlayBoulderDash;

        fSpeed = 0x120;
        fIndex = 0;
        rotateOffset = 0;
    }

#endif

    frameAdjustX = frameAdjustY = 0;
    frameAdjustSmallX = frameAdjustSmallY = 0;
    rockfordDirection = 1;


    for (int bgLine = 0; bgLine < 24; bgLine++)
        bgPalette[bgLine] = caveList[cave].caveColour[0][3+ bgLine];


//    DecodeCave(caveList[cave].cavePtr);
    gameSchedule = SCHEDULE_UNPACK_CAVE;





    forceScoreDraw = SCOREVISIBLETIME;

    // for (int i = 0; i < (40*24)/8; i++)
    //     RAM[_UNCOVER + i] = 0xFF;

    for (int i = 0; i < TYPE_MAX; i++) {
        AnimIdx[i].index = -2;
        AnimIdx[i].count = 0;
    }

//    AnimIdx[TYPE_BOULDER_SHAKE].count = -1;



    playerAnimationID = -1;
    setAnimation(ID_BLANK);

//    attractCounter = 0;
//    setColours();

    caveCompleted = false;

    selectResetDelay = 0;
    scoreCycle = 2;

    for (int i = 0; i < 10; i++)
        scoreLineCurrent[i] = -1;


    // uncoverCount = 1; // or 100
    //AddAudio(SFX_UNCOVER);
//    AddAudio(SFX_DEADBEAT2);

}



void Initialize() {
    
    // during Initialize() SWCHA contains the results of the 6507 routine which
    // detects if the console is a 2600 or 7800.
    is_7800 = SWCHA;    // 0 = 2600, non-zero = 7800
        
    // When the Harmon/y Melody is powered up the 4K of Display Data RAM will
    // contain random values, so we should zero it out to have a known starting
    // point. Using myMemsetInt is faster than using myMemset, but requires
    // dividing the number of bytes by 4 because an integer is stored in 4 bytes.

    for (int i = 0; i < 4096/4; i++)
        RAM_INT[i] = 0;

    // for (int i = 0; i < 40; i++)
    //     RAM[_SHAKE_FIX + i] = CH_STEEL;

    //myMemsetInt(RAM_INT, 0, 4096/4);
    
    // likewise the datastream increments will be random, so set them to 1.0
    for(int i = 0; i <= 34; i++)
        setIncrement(i, 1, 0);


    actualScore = 0;
    partialScore = 0;

    cave = 0;
    lives = 3;
    level = 0;

    selectResetDelay = 0;


    pfBuffer = 0;


    InitAudio();
    InitGameX();

    InitGameBuffers();

    setPalette(0, PIECE_DEPTH, 3, 3);
}






void GameScheduleDrawSprites();
// #if ENABLE_OVERLAY
// void GameScheduleDrawOverlay();
// #endif
void GameScheduleAnimate();
void GameScheduleProcessBoardRow();



void Scheduler() {

    switch (gameSchedule) {
    case SCHEDULE_UNPACK_CAVE:
        gameSchedule = SCHEDULE_START;
        break;
    case SCHEDULE_START:
        SetupBoard();
        break;
    case SCHEDULE_PROCESSBOARD:
        GameScheduleProcessBoardRow();
        break;
    default:
        break;
    }
}

const unsigned int bufPtr[][2]= {

    { _BUF_A_PF0_LEFT, _BUF_B_PF0_LEFT },
    { _BUF_A_PF1_LEFT, _BUF_B_PF1_LEFT },
    { _BUF_A_PF2_LEFT, _BUF_B_PF2_LEFT },

    { _BUF_A_PF0_RIGHT, _BUF_B_PF0_RIGHT },
    { _BUF_A_PF1_RIGHT, _BUF_B_PF1_RIGHT },
    { _BUF_A_PF2_RIGHT, _BUF_B_PF2_RIGHT },
};


void InitGameDatastreams() {

    int visibleBuffer = pfBuffer ^ 1;

    // initialize the Data Streams for the Arena
    setPointer(_DS_PF0_LEFT,  bufPtr[0][visibleBuffer]);
    setPointer(_DS_PF1_LEFT,  bufPtr[1][visibleBuffer]);
    setPointer(_DS_PF2_LEFT,  bufPtr[2][visibleBuffer]);
    setPointer(_DS_PF0_RIGHT, bufPtr[3][visibleBuffer]);
    setPointer(_DS_PF1_RIGHT, bufPtr[4][visibleBuffer]);
    setPointer(_DS_PF2_RIGHT, bufPtr[5][visibleBuffer]);

    setPointer(_DS_AUDV0, _BUF_AUDV);
    setPointer(_DS_AUDC0, _BUF_AUDC);
    setPointer(_DS_AUDF0, _BUF_AUDF);

    setPointer(_DS_COLUPF, _BUF_COLUPF);
    setPointer(_DS_COLUBK, _BUF_COLUBK);
    setPointer(_DS_COLUP0, _BUF_COLUP0);
    setPointer(_DS_COLUP1, _BUF_COLUP1);

    setPointer(_DS_GRP0a, _BUF_GRP0A);
    setPointer(_DS_GRP1a, _BUF_GRP1A);

    // initialize the Jump Data Stream
    setPointer(0x21, _BUF_JUMP1);
}


//==============================================================================
// Game routines
//--------------------------------------
//  All game logic runs in OverScan
//  All prep of the datastreams runs in Vertical Blank
//==============================================================================




void GameOverscan() {


    // for (int sp=0; sp< 1; sp++) {
    //     drawSoftwareSprites();
    //     if (finished) {
    //         pfBuffer ^= 1;
    //         drawScreen();
    //         finished = false;
    //         break;
    //     }
    // }

    // InitGameDatastreams();

    // Scroll();
    // GameScheduleDrawSprites();

    // InitGameDatastreams();
//    playAudio();
//    GameScheduleAnimate();
}



int controlledLayer = 0;
int highlightLayer = 0;
bool showHighlight = false;
int jDelay = 0;

void HandleJoystick() {

    if (!jDelay && !highlightLayer) {

        if (JOY0_UP) {
            highlightLayer = 3;
            jDelay = 20;
            controlledLayer++;
            if (controlledLayer > 2)
                controlledLayer = 0;
        }

        if (JOY0_DOWN) {
            highlightLayer = 3;
            jDelay = 20;
            controlledLayer--;
            if (controlledLayer < 0)
                controlledLayer = 2;
        }

        if (JOY0_LEFT && !(rotateTop[controlledLayer] & 3)) {

            if (JOY0_FIRE)
                for (int layer = 0; layer < 3; layer++)
                    direct[layer] = 1;


            direct[controlledLayer] = 1;
        }


        if (JOY0_RIGHT && !(rotateTop[controlledLayer] & 3)) {

            if (JOY0_FIRE)
                for (int layer = 0; layer < 3; layer++)
                    direct[layer] = -1;


            direct[controlledLayer] = -1;
        }

    }

    if (jDelay)
        jDelay--;
}



void GameVerticalBlank() {
 

    Scroll();


    if (finished) {
        pfBuffer ^= 1;
        drawScreen();
        finished = false;
    }

    // else
    //     drawSoftwareSprites();


    HandleJoystick();

    GameScheduleDrawSprites();



    frameCounter++;
    frameToggler++;


    // for (int sp=0; sp< 3; sp++) {
    //     if (finished) {
    //         pfBuffer ^= 1;
    //         drawScreen();
    //         finished = false;
    //         break;
    //     }


    //     drawSoftwareSprites();

    // }

    InitGameDatastreams();


    // if (time && /*!uncoverCount &&*/ !rockfordDead) {

    //     time--;
    //     if ((time & 0xFF) == 0xFF) {

    //         time -= 0xC4;           // magic!  - (-256+60)
    //         if (time < 0xA00) {
    //             scoreCycle = 0;
    //             forceScoreDraw = SCOREVISIBLETIME;
    //             AddAudio(SFX_COUNTDOWN2);
    //         }
    //     }
    // }



//     if (gameSchedule != SCHEDULE_UNPACK_CAVE) {

// //        drawBitmap(&rocketShip[0], 30, lava-(scrollY>>16), false);


// //        GameScheduleAnimate();
// // #if ENABLE_OVERLAY
// //         GameScheduleDrawOverlay();
// // #endif
//         // Uncover();

// extern void     looneyTuneFade();

//         looneyTuneFade();
//     }
}



void setPalette(int start, int size, int step, int tweak) {

    setColours();

    int bgCharLine = (scrollY >> 16) * 3;
    int absLine = 0;
    int pfCharLine = 0;
    
    if (start) {
        absLine = bgCharLine;
        bgCharLine--;

        while (bgCharLine >= size) {
            bgCharLine -= size;
            pfCharLine++;
        }
    }



    int i = start;
    while (i < _ARENA_SCANLINES) {

        // if (lava && absLine >= lavaLine) {

        //     unsigned char lavaCol = 0x44;
        //     int delta = (absLine - lavaLine);

        //     if (delta < 14) {
        //         lavaCol = 0x2E - (delta >> 2);
        //     } else {

        //         lavaCol = 0x4A - (delta >> 3);
        //         if (lavaCol < 0x44)
        //             lavaCol = 0x44;
        //     }

        //     //if (!flashTime) {
        //         RAM[_BUF_COLUBK + i ] = 
        //         RAM[_BUF_COLUBK + i + 1 ] =
        //         RAM[_BUF_COLUBK + i + 2] = ColourConvert(lavaCol);
        //     //}

        //     RAM[_BUF_COLUPF + i] = ColourConvert(0x48);
        //     RAM[_BUF_COLUPF + i + 1 ] = ColourConvert(0x28);
        //     RAM[_BUF_COLUPF + i + 2 ] = ColourConvert(0x3c);

        // }
        
        // else if (water && absLine >= waterLine) {

        //     unsigned char waterCol = 0x90;
        //     int delta = absLine - waterLine;
        //     if (delta < 32) {
        //         waterCol += (32 - delta) >> 2;
        //     }


        //     //if (!flashTime) {

        //         RAM[_BUF_COLUBK + i ] = ColourConvert(waterCol);
        //         RAM[_BUF_COLUBK + i + 1 ] = ColourConvert(waterCol);
        //         RAM[_BUF_COLUBK + i + 2 ] = ColourConvert(waterCol);

        //     //}

        //     RAM[_BUF_COLUPF + i ] = ColourConvert(0xA4);
        //     RAM[_BUF_COLUPF + i + 1] = ColourConvert(0x84);     // boulder body
        //     RAM[_BUF_COLUPF + i + 2] = ColourConvert(0x94);     // flow + inside stream colour

        // }
        // else {
            RAM[_BUF_COLUPF + i] = ColourConvert(bgPalette[pfCharLine]);
        // }
        
            
        bgCharLine += 3;            
        if (bgCharLine >= size) {
            bgCharLine = 0;
            pfCharLine++;
        }


        absLine += step;
        i+=3;
    }

}




void setOverviewPalette() {

    setPalette(0, 9, 7, 6);

}

void setDisplayPalette() {
//    setPalette(0, PIECE_DEPTH, 3, 3);
}



int sortOrder[SPACESHIPS];





// three axes
// A/B/C layers for each
// each layer has a rotation (0-3)
// for all facets {
    // facet shape
    // x,y posn
    // face=cube=ref-> lookup colour
    //      --> lookup shape[colour] --> pattern to draw
    //}



#define AXES 1
#define ROTATE 16







struct facet {
    int face;
    int colour;
    int x;
    int y;
    int square;
    bool topOnly;
};


#define MARKER 0


struct facet shapeDef[AXES][ROTATE][25] = {

    {

        // 0  ISO
         
        {   // THIS GROUPING DEFINES DISPLAY OF A LAYER (e.g, one row or column of a cube)

            // multiple facets, each...
            // visibleShape, colour, x, y, face# (to get colour), topOnly

            // visibleShape:
            // 0                TOP
            // 1                LEFT
            // 2                RIGHT
            // 3    ... more rotations to be added


            // topOnly:
            // true             a part of the 3x3 "top" of the layer
            // false            always drawn


    #if !MARKER
            // top facets

            {   0, 2,  14, 0x0A0000,   0,    true,    },
            {   0, 1,   9, 0x0F0000,   1,    true,    },
            {   0, 2,  19, 0x0F0000,   2,    true,    },
            {   0, 3,   4, 0x140000,   3,    true,    },
            {   0, 4,  14, 0x140000,   4,    true,    },
            {   0, 5,  24, 0x140000,   5,    true,    },
            {   0, 6,   9, 0x190000,   6,    true,    },
            {   0, 7,  19, 0x190000,   7,    true,    },
            {   0, 1,  14, 0x1E0000,   8,    true,    },

            // left facets

            {   1, 6,   4, 0x140000,   6,    false,   },       // L0
            {   1, 1,   9, 0x190000,   7,    false,   },       // L1
            {   1, 3,  14, 0x1E0000,   8,    false,   },       // L2 (@CENTER)

            // right facets

            {   2, 3,  24, 0x140000,   6,    false,   },
            {   2, 1,  19, 0x190000,   7,    false,   },
            {   2, 6,  14, 0x1E0000,   8,    false,   },

    #endif

    #if MARKER
            // top facets

            {  12, 2,  14, 0x0A0000,   0,    true,    },
            {  12, 1,   9, 0x0F0000,   1,    true,    },
            {  12, 2,  19, 0x0F0000,   2,    true,    },
            {  12, 3,   4, 0x140000,   3,    true,    },
            {  12, 4,  14, 0x140000,   4,    true,    },
            {  12, 5,  24, 0x140000,   5,    true,    },
            {  12, 6,   9, 0x190000,   6,    true,    },
            {  12, 7,  19, 0x190000,   7,    true,    },
            {  12, 1,  14, 0x1E0000,   8,    true,    },

            // left facets

            {  12, 6,   4, 0x140000,   6,    false,   },       // L0
            {  12, 1,   9, 0x190000,   7,    false,   },       // L1
            {  12, 3,  14, 0x1E0000,   8,    false,   },       // L2 (@CENTER)

            // right facets

            {  12, 3,  24, 0x140000,   6,    false,   },
            {  12, 1,  19, 0x190000,   7,    false,   },
            {  12, 6,  14, 0x1E0000,   8,    false,   },

    #endif


            {   -1,  0,0,0,    false,   },
        },
 

        // 1 tilt

        {   // THIS GROUPING DEFINES DISPLAY OF A LAYER (e.g, one row or column of a cube)

            // multiple facets, each...
            // visibleShape, x, y, face# (to get colour), topOnly

            // visibleShape:
            // 0                TOP
            // 1                LEFT
            // 2                RIGHT
            // 3    ... more rotations to be added


            // topOnly:
            // true             a part of the 3x3 "top" of the layer
            // false            always drawn


            // {   8, 0,  4, 0x150000,   0,    false,    },       // cube boundary
            // {   8, 1, 14, 0x1E0000,   0,    false,    },       // cube boundary


            // top facets

            {   7, 2,  17-1, 0x0D0000-0x10000,   0,    true,    },
            {   7, 1,  11-1, 0x100000-0x10000,   1,    true,    },
            {   7, 2,  20-1, 0x140000-0x10000,   2,    true,    },
            {   7, 3,   5-1, 0x130000-0x10000,   3,    true,    },
            {   7, 4,  14-1, 0x170000-0x20000,   4,    true,    },
            {   7, 5,  23-1, 0x1C0000-0x20000,   5,    true,    },
            {   7, 6,   8-1, 0x1A0000-0x10000,   6,    true,    },
            {   7, 7,  17-1, 0x1F0000-0x20000,   7,    true,    },
            {   7, 1,  11-1, 0x220000-0x20000,   8,    true,    },

            // left facets

            {   6, 6,   5-1, 0x110000-0x20000,   6,    false,   },       // L0
            {   6, 1,   8-1, 0x190000-0x30000,   7,    false,   },       // L1
            {   6, 3,  11-1, 0x200000-0x20000,   8,    false,   },       // L2 (@CENTER)

            // right facets

            {   5, 3,  23-1, 0x1C0000-0x20000,   6,    false,   },
            {   5, 1,  17-1, 0x1F0000-0x20000,   7,    false,   },
            {   5, 6,  11-1, 0x220000-0x20000,   8,    false,   },

            {   -1,  0,0,0,    false,   },
        },

        // 2 flat

        {   // THIS GROUPING DEFINES DISPLAY OF A LAYER (e.g, one row or column of a cube)

            // multiple facets, each...
            // visibleShape, x, y, face# (to get colour), topOnly

            // visibleShape:
            // 0                TOP
            // 1                LEFT
            // 2                RIGHT
            // 3    ... more rotations to be added


            // topOnly:
            // true             a part of the 3x3 "top" of the layer
            // false            always drawn


            // {   8, 0,  4, 0x150000,   0,    false,    },       // cube boundary
            // {   8, 1, 14, 0x1E0000,   0,    false,    },       // cube boundary

            // top facets

            {   3, 3,  8, 0x0F0000,   0,    true,    },
            {   3, 1, 15, 0x0F0000,   1,    true,    },
            {   3, 2, 22, 0x0F0000,   2,    true,    },
            {   3, 6,  8, 0x160000,   3,    true,    },
            {   3, 4, 15, 0x160000,   4,    true,    },
            {   3, 2, 22, 0x160000,   5,    true,    },
            {   3, 1,  8, 0x1E0000,   6,    true,    },
            {   3, 7, 15, 0x1E0000,   7,    true,    },
            {   3, 5, 22, 0x1E0000,   8,    true,    },

            // right facets (now face-on)

            {   4, 6,   8, 0x240000,   6,    false,   },       // L0
            {   4, 1,  15, 0x240000,   7,    false,   },       // L1
            {   4, 3,  22, 0x240000,   8,    false,   },       // L2 (@CENTER)


            {   -1,  0,0,0,    false,   },
        },
 
 
        // 3 tilt2
        {   // THIS GROUPING DEFINES DISPLAY OF A LAYER (e.g, one row or column of a cube)

            // multiple facets, each...
            // visibleShape, x, y, face# (to get colour), topOnly

            // visibleShape:
            // 0                TOP
            // 1                LEFT
            // 2                RIGHT
            // 3    ... more rotations to be added


            // topOnly:
            // true             a part of the 3x3 "top" of the layer
            // false            always drawn


            // {   8, 0,  4, 0x150000,   0,    false,    },       // cube boundary
            // {   8, 1, 14, 0x1E0000,   0,    false,    },       // cube boundary


            // top facets

            {   9, 3,  5+(23-(17-1)), 0x0D0000-0x10000,   0,    true,    },
            {   9, 1,  5+(23-(11-1)), 0x100000-0x10000,   1,    true,    },
            {   9, 6,  5+(23-(20-1)), 0x140000-0x10000,   2,    true,    },
            {   9, 2,  5+(23-( 5-1)), 0x130000-0x10000,   3,    true,    },
            {   9, 4,  5+(23-(14-1)), 0x170000-0x20000,   4,    true,    },
            {   9, 2,  5+(23-( 8-1)), 0x1A0000-0x10000,   6,    true,    },
            {   9, 1,  5+(23-(23-1)), 0x1C0000-0x20000,   5,    true,    },
            {   9, 7,  5+(23-(17-1)), 0x1F0000-0x20000,   7,    true,    },
            {   9, 5,  5+(23-(11-1)), 0x220000-0x20000,   8,    true,    },

            // right facets

            {   10, 6,   5+(23-(5-1)), 0x110000-0x20000,   6,    false,   },       // L0
            {   10, 4,   5+(23-(8-1)), 0x190000-0x30000,   7,    false,   },       // L1
            {   10, 4,  5+(23-(11-1)), 0x200000-0x20000,   8,    false,   },       // L2 (@CENTER)

            // left facets

            {   11, 6,  5+(23-(23-1)), 0x1C0000-0x20000,   6,    false,   },
            {   11, 1,  5+(23-(17-1)), 0x1F0000-0x20000,   7,    false,   },
            {   11, 3,  5+(23-(11-1)), 0x220000-0x20000,   8,    false,   },

            {   -1,  0,0,0,    false,   },
        },

        // 4 ISO

        {   // THIS GROUPING DEFINES DISPLAY OF A LAYER (e.g, one row or column of a cube)

            // multiple facets, each...
            // visibleShape, x, y, face# (to get colour), topOnly

            // visibleShape:
            // 0                TOP
            // 1                LEFT
            // 2                RIGHT
            // 3    ... more rotations to be added


            // topOnly:
            // true             a part of the 3x3 "top" of the layer
            // false            always drawn

            // top facets

            {   0, 3,  14, 0x0A0000,   0,    true,    },
            {   0, 6,   9, 0x0F0000,   1,    true,    },
            {   0, 1,  19, 0x0F0000,   2,    true,    },
            {   0, 1,   4, 0x140000,   3,    true,    },
            {   0, 4,  14, 0x140000,   4,    true,    },
            {   0, 2,  24, 0x140000,   5,    true,    },
            {   0, 7,   9, 0x190000,   6,    true,    },
            {   0, 2,  19, 0x190000,   7,    true,    },
            {   0, 5,  14, 0x1E0000,   8,    true,    },

            // left facets

            {   1, 6,   4, 0x140000,   6,    false,   },       // L0
            {   1, 1,   9, 0x190000,   7,    false,   },       // L1
            {   1, 3,  14, 0x1E0000,   8,    false,   },       // L2 (@CENTER)

            // right facets

            {   2, 6,  24, 0x140000,   6,    false,   },
            {   2, 4,  19, 0x190000,   7,    false,   },
            {   2, 4,  14, 0x1E0000,   8,    false,   },

            {   -1,  0,0,0,    false,   },
        },


        // 5 TILT

        {   // THIS GROUPING DEFINES DISPLAY OF A LAYER (e.g, one row or column of a cube)

            // multiple facets, each...
            // visibleShape, x, y, face# (to get colour), topOnly

            // visibleShape:
            // 0                TOP
            // 1                LEFT
            // 2                RIGHT
            // 3    ... more rotations to be added


            // topOnly:
            // true             a part of the 3x3 "top" of the layer
            // false            always drawn


            // {   8, 0,  4, 0x150000,   0,    false,    },       // cube boundary
            // {   8, 1, 14, 0x1E0000,   0,    false,    },       // cube boundary


            // top facets

            {   7, 3,  17-1, 0x0D0000-0x10000,   0,    true,    },
            {   7, 6,  11-1, 0x100000-0x10000,   1,    true,    },
            {   7, 1,  20-1, 0x140000-0x10000,   2,    true,    },
            {   7, 1,   5-1, 0x130000-0x10000,   3,    true,    },
            {   7, 4,  14-1, 0x170000-0x20000,   4,    true,    },
            {   7, 2,  23-1, 0x1C0000-0x20000,   5,    true,    },
            {   7, 7,   8-1, 0x1A0000-0x10000,   6,    true,    },
            {   7, 2,  17-1, 0x1F0000-0x20000,   7,    true,    },
            {   7, 5,  11-1, 0x220000-0x20000,   8,    true,    },

            // left facets

            {   6, 6,   5-1, 0x110000-0x20000,   6,    false,   },       // L0
            {   6, 1,   8-1, 0x190000-0x30000,   7,    false,   },       // L1
            {   6, 3,  11-1, 0x200000-0x20000,   8,    false,   },       // L2 (@CENTER)

            // right facets

            {   5, 6,  23-1, 0x1C0000-0x20000,   6,    false,   },
            {   5, 4,  17-1, 0x1F0000-0x20000,   7,    false,   },
            {   5, 4,  11-1, 0x220000-0x20000,   8,    false,   },

            {   -1,  0,0,0,    false,   },
        },


        // 6 FLAT
        {   // THIS GROUPING DEFINES DISPLAY OF A LAYER (e.g, one row or column of a cube)

            // multiple facets, each...
            // visibleShape, x, y, face# (to get colour), topOnly

            // visibleShape:
            // 0                TOP
            // 1                LEFT
            // 2                RIGHT
            // 3    ... more rotations to be added


            // topOnly:
            // true             a part of the 3x3 "top" of the layer
            // false            always drawn

            // top facets

            {   3, 1,  8, 0x0F0000,   0,    true,    },
            {   3, 6, 15, 0x0F0000,   1,    true,    },
            {   3, 3, 22, 0x0F0000,   2,    true,    },
            {   3, 7,  8, 0x160000,   3,    true,    },
            {   3, 4, 15, 0x160000,   4,    true,    },
            {   3, 1, 22, 0x160000,   5,    true,    },
            {   3, 5,  8, 0x1E0000,   6,    true,    },
            {   3, 2, 15, 0x1E0000,   7,    true,    },
            {   3, 2, 22, 0x1E0000,   8,    true,    },

            // right facets (now face-on)

            {   4, 4,   8, 0x240000,   6,    false,   },       // L0
            {   4, 4,  15, 0x240000,   7,    false,   },       // L1
            {   4, 6,  22, 0x240000,   8,    false,   },       // L2 (@CENTER)

            {   -1,  0,0,0,    false,   },
        },
 

        // 7 TILT2
         {   // THIS GROUPING DEFINES DISPLAY OF A LAYER (e.g, one row or column of a cube)

            // multiple facets, each...
            // visibleShape, x, y, face# (to get colour), topOnly

            // visibleShape:
            // 0                TOP
            // 1                LEFT
            // 2                RIGHT
            // 3    ... more rotations to be added


            // topOnly:
            // true             a part of the 3x3 "top" of the layer
            // false            always drawn


            // {   8, 0,  4, 0x150000,   0,    false,    },       // cube boundary
            // {   8, 1, 14, 0x1E0000,   0,    false,    },       // cube boundary


            // top facets

            {   9, 1,  4+(23-(17-1)), 0x0D0000-0x10000,   0,    true,    },
            {   9, 6,  4+(23-(11-1)), 0x100000-0x10000,   1,    true,    },
            {   9, 7,  4+(23-(20-1)), 0x140000-0x10000,   2,    true,    },
            {   9, 3,  4+(23-( 5-1)), 0x130000-0x10000,   3,    true,    },
            {   9, 4,  4+(23-(14-1)), 0x170000-0x20000,   4,    true,    },
            {   9, 1,  4+(23-( 8-1)), 0x1A0000-0x10000,   6,    true,    },
            {   9, 5,  4+(23-(23-1)), 0x1C0000-0x20000,   5,    true,    },
            {   9, 2,  4+(23-(17-1)), 0x1F0000-0x20000,   7,    true,    },
            {   9, 2,  4+(23-(11-1)), 0x220000-0x20000,   8,    true,    },

            // right facets

            {   10, 5,   4+(23-(5-1)), 0x110000-0x20000,   6,    false,   },       // L0
            {   10, 5,   4+(23-(8-1)), 0x190000-0x30000,   7,    false,   },       // L1
            {   10, 3,  4+(23-(11-1)), 0x200000-0x20000,   8,    false,   },       // L2 (@CENTER)

            // left facets

            {   11, 4,  4+(23-(23-1)), 0x1C0000-0x20000,   6,    false,   },
            {   11, 4,  4+(23-(17-1)), 0x1F0000-0x20000,   7,    false,   },
            {   11, 6,  4+(23-(11-1)), 0x220000-0x20000,   8,    false,   },

            {   -1,  0,0,0,    false,   },
        },


        // 8 ISO
         {   // THIS GROUPING DEFINES DISPLAY OF A LAYER (e.g, one row or column of a cube)

            // multiple facets, each...
            // visibleShape, x, y, face# (to get colour), topOnly

            // visibleShape:
            // 0                TOP
            // 1                LEFT
            // 2                RIGHT
            // 3    ... more rotations to be added


            // topOnly:
            // true             a part of the 3x3 "top" of the layer
            // false            always drawn

            // top facets

            {   0, 1,  14, 0x0A0000,   0,    true,    },
            {   0, 7,   9, 0x0F0000,   1,    true,    },
            {   0, 6,  19, 0x0F0000,   2,    true,    },
            {   0, 5,   4, 0x140000,   3,    true,    },
            {   0, 4,  14, 0x140000,   4,    true,    },
            {   0, 3,  24, 0x140000,   5,    true,    },
            {   0, 2,   9, 0x190000,   6,    true,    },
            {   0, 1,  19, 0x190000,   7,    true,    },
            {   0, 2,  14, 0x1E0000,   8,    true,    },

            // left facets

            {   1, 4,   4, 0x140000,   6,    false,   },       // L0
            {   1, 4,   9, 0x190000,   7,    false,   },       // L1
            {   1, 6,  14, 0x1E0000,   8,    false,   },       // L2 (@CENTER)

            // right facets

            {   2, 5,  24, 0x140000,   6,    false,   },
            {   2, 5,  19, 0x190000,   7,    false,   },
            {   2, 3,  14, 0x1E0000,   8,    false,   },

            {   -1,  0,0,0,    false,   },
        },

 
        // 9 TILT
        {   // THIS GROUPING DEFINES DISPLAY OF A LAYER (e.g, one row or column of a cube)

            // multiple facets, each...
            // visibleShape, x, y, face# (to get colour), topOnly

            // visibleShape:
            // 0                TOP
            // 1                LEFT
            // 2                RIGHT
            // 3    ... more rotations to be added


            // topOnly:
            // true             a part of the 3x3 "top" of the layer
            // false            always drawn


            // {   8, 0,  4, 0x150000,   0,    false,    },       // cube boundary
            // {   8, 1, 14, 0x1E0000,   0,    false,    },       // cube boundary


            // top facets

            {   7, 1,  17-1, 0x0D0000-0x10000,   0,    true,    },
            {   7, 7,  11-1, 0x100000-0x10000,   1,    true,    },
            {   7, 6,  20-1, 0x140000-0x10000,   2,    true,    },
            {   7, 5,   5-1, 0x130000-0x10000,   3,    true,    },
            {   7, 4,  14-1, 0x170000-0x20000,   4,    true,    },
            {   7, 3,  23-1, 0x1C0000-0x20000,   5,    true,    },
            {   7, 2,   8-1, 0x1A0000-0x10000,   6,    true,    },
            {   7, 1,  17-1, 0x1F0000-0x20000,   7,    true,    },
            {   7, 2,  11-1, 0x220000-0x20000,   8,    true,    },

            // left facets

            {   6, 4,   5-1, 0x110000-0x20000,   6,    false,   },       // L0
            {   6, 4,   8-1, 0x190000-0x30000,   7,    false,   },       // L1
            {   6, 6,  11-1, 0x200000-0x20000,   8,    false,   },       // L2 (@CENTER)

            // right facets

            {   5, 5,  23-1, 0x1C0000-0x20000,   6,    false,   },
            {   5, 5,  17-1, 0x1F0000-0x20000,   7,    false,   },
            {   5, 3,  11-1, 0x220000-0x20000,   8,    false,   },

            {   -1,  0,0,0,    false,   },
        },


        // 10 ISO
        {   // THIS GROUPING DEFINES DISPLAY OF A LAYER (e.g, one row or column of a cube)

            // multiple facets, each...
            // visibleShape, x, y, face# (to get colour), topOnly

            // visibleShape:
            // 0                TOP
            // 1                LEFT
            // 2                RIGHT
            // 3    ... more rotations to be added


            // topOnly:
            // true             a part of the 3x3 "top" of the layer
            // false            always drawn

            // top facets

            {   3, 5,  8, 0x0F0000,   0,    true,    },
            {   3, 7, 15, 0x0F0000,   1,    true,    },
            {   3, 1, 22, 0x0F0000,   2,    true,    },
            {   3, 2,  8, 0x160000,   3,    true,    },
            {   3, 4, 15, 0x160000,   4,    true,    },
            {   3, 6, 22, 0x160000,   5,    true,    },
            {   3, 2,  8, 0x1E0000,   6,    true,    },
            {   3, 1, 15, 0x1E0000,   7,    true,    },
            {   3, 3, 22, 0x1E0000,   8,    true,    },

            // right facets (now face-on)

            {   4, 3,   8, 0x240000,   6,    false,   },       // L0
            {   4, 5,  15, 0x240000,   7,    false,   },       // L1
            {   4, 5,  22, 0x240000,   8,    false,   },       // L2 (@CENTER)

            {   -1,  0,0,0,    false,   },
        },
 
 

        // 11 tilt2
         {   // THIS GROUPING DEFINES DISPLAY OF A LAYER (e.g, one row or column of a cube)

            // multiple facets, each...
            // visibleShape, x, y, face# (to get colour), topOnly

            // visibleShape:
            // 0                TOP
            // 1                LEFT
            // 2                RIGHT
            // 3    ... more rotations to be added


            // topOnly:
            // true             a part of the 3x3 "top" of the layer
            // false            always drawn


            // {   8, 0,  4, 0x150000,   0,    false,    },       // cube boundary
            // {   8, 1, 14, 0x1E0000,   0,    false,    },       // cube boundary


            // top facets

            {   9, 5,  4+(23-(17-1)), 0x0D0000-0x10000,   0,    true,    },
            {   9, 7,  4+(23-(11-1)), 0x100000-0x10000,   1,    true,    },
            {   9, 2,  4+(23-(20-1)), 0x140000-0x10000,   2,    true,    },
            {   9, 1,  4+(23-( 5-1)), 0x130000-0x10000,   3,    true,    },
            {   9, 4,  4+(23-(14-1)), 0x170000-0x20000,   4,    true,    },
            {   9, 6,  4+(23-( 8-1)), 0x1A0000-0x10000,   6,    true,    },
            {   9, 2,  4+(23-(23-1)), 0x1C0000-0x20000,   5,    true,    },
            {   9, 1,  4+(23-(17-1)), 0x1F0000-0x20000,   7,    true,    },
            {   9, 3,  4+(23-(11-1)), 0x220000-0x20000,   8,    true,    },

            // right facets

            {   10, 3,   4+(23-(5-1)), 0x110000-0x20000,   6,    false,   },       // L0
            {   10, 1,   4+(23-(8-1)), 0x190000-0x30000,   7,    false,   },       // L1
            {   10, 6,  4+(23-(11-1)), 0x200000-0x20000,   8,    false,   },       // L2 (@CENTER)

            // left facets

            {   11, 3,  4+(23-(23-1)), 0x1C0000-0x20000,   6,    false,   },
            {   11, 5,  4+(23-(17-1)), 0x1F0000-0x20000,   7,    false,   },
            {   11, 5,  4+(23-(11-1)), 0x220000-0x20000,   8,    false,   },

            {   -1,  0,0,0,    false,   },
        },


        // 12

         {   // THIS GROUPING DEFINES DISPLAY OF A LAYER (e.g, one row or column of a cube)

            // multiple facets, each...
            // visibleShape, x, y, face# (to get colour), topOnly

            // visibleShape:
            // 0                TOP
            // 1                LEFT
            // 2                RIGHT
            // 3    ... more rotations to be added


            // topOnly:
            // true             a part of the 3x3 "top" of the layer
            // false            always drawn

            // top facets

            {   0, 5,  14, 0x0A0000,   0,    true,    },
            {   0, 2,   9, 0x0F0000,   1,    true,    },
            {   0, 7,  19, 0x0F0000,   2,    true,    },
            {   0, 2,   4, 0x140000,   3,    true,    },
            {   0, 4,  14, 0x140000,   4,    true,    },
            {   0, 1,  24, 0x140000,   5,    true,    },
            {   0, 1,   9, 0x190000,   6,    true,    },
            {   0, 6,  19, 0x190000,   7,    true,    },
            {   0, 3,  14, 0x1E0000,   8,    true,    },

            // left facets

            {   1, 3,   4, 0x140000,   6,    false,   },       // L0
            {   1, 5,   9, 0x190000,   7,    false,   },       // L1
            {   1, 5,  14, 0x1E0000,   8,    false,   },       // L2 (@CENTER)

            // right facets

            {   2, 3,  24, 0x140000,   6,    false,   },
            {   2, 1,  19, 0x190000,   7,    false,   },
            {   2, 6,  14, 0x1E0000,   8,    false,   },

            {   -1,  0,0,0,    false,   },
        },


        // 13 TILT

        {   // THIS GROUPING DEFINES DISPLAY OF A LAYER (e.g, one row or column of a cube)

            // multiple facets, each...
            // visibleShape, x, y, face# (to get colour), topOnly

            // visibleShape:
            // 0                TOP
            // 1                LEFT
            // 2                RIGHT
            // 3    ... more rotations to be added


            // topOnly:
            // true             a part of the 3x3 "top" of the layer
            // false            always drawn


            // {   8, 0,  4, 0x150000,   0,    false,    },       // cube boundary
            // {   8, 1, 14, 0x1E0000,   0,    false,    },       // cube boundary


            // top facets

            {   7, 5,  17-1, 0x0D0000-0x10000,   0,    true,    },
            {   7, 2,  11-1, 0x100000-0x10000,   1,    true,    },
            {   7, 7,  20-1, 0x140000-0x10000,   2,    true,    },
            {   7, 2,   5-1, 0x130000-0x10000,   3,    true,    },
            {   7, 4,  14-1, 0x170000-0x20000,   4,    true,    },
            {   7, 1,  23-1, 0x1C0000-0x20000,   5,    true,    },
            {   7, 1,   8-1, 0x1A0000-0x10000,   6,    true,    },
            {   7, 6,  17-1, 0x1F0000-0x20000,   7,    true,    },
            {   7, 3,  11-1, 0x220000-0x20000,   8,    true,    },

            // left facets

            {   6, 3,   5-1, 0x110000-0x20000,   6,    false,   },       // L0
            {   6, 5,   8-1, 0x190000-0x30000,   7,    false,   },       // L1
            {   6, 5,  11-1, 0x200000-0x20000,   8,    false,   },       // L2 (@CENTER)

            // right facets

            {   5, 3,  23-1, 0x1C0000-0x20000,   6,    false,   },
            {   5, 1,  17-1, 0x1F0000-0x20000,   7,    false,   },
            {   5, 6,  11-1, 0x220000-0x20000,   8,    false,   },

            {   -1,  0,0,0,    false,   },
        },



        // 14
        {   // THIS GROUPING DEFINES DISPLAY OF A LAYER (e.g, one row or column of a cube)

            // multiple facets, each...
            // visibleShape, x, y, face# (to get colour), topOnly

            // visibleShape:
            // 0                TOP
            // 1                LEFT
            // 2                RIGHT
            // 3    ... more rotations to be added


            // topOnly:
            // true             a part of the 3x3 "top" of the layer
            // false            always drawn

            // top facets

            {   3, 2,  8, 0x0F0000,   0,    true,    },
            {   3, 2, 15, 0x0F0000,   1,    true,    },
            {   3, 5, 22, 0x0F0000,   2,    true,    },
            {   3, 1,  8, 0x160000,   3,    true,    },
            {   3, 4, 15, 0x160000,   4,    true,    },
            {   3, 7, 22, 0x160000,   5,    true,    },
            {   3, 3,  8, 0x1E0000,   6,    true,    },
            {   3, 6, 15, 0x1E0000,   7,    true,    },
            {   3, 1, 22, 0x1E0000,   8,    true,    },

            // right facets (now face-on)

            {   4, 6,   8, 0x240000,   6,    false,   },       // L0
            {   4, 1,  15, 0x240000,   7,    false,   },       // L1
            {   4, 3,  22, 0x240000,   8,    false,   },       // L2 (@CENTER)


            {   -1,  0,0,0,    false,   },
        },
 
 
            //xxx
        // 15 tilt2
         {   // THIS GROUPING DEFINES DISPLAY OF A LAYER (e.g, one row or column of a cube)

            // multiple facets, each...
            // visibleShape, x, y, face# (to get colour), topOnly

            // visibleShape:
            // 0                TOP
            // 1                LEFT
            // 2                RIGHT
            // 3    ... more rotations to be added


            // topOnly:
            // true             a part of the 3x3 "top" of the layer
            // false            always drawn


            // {   8, 0,  4, 0x150000,   0,    false,    },       // cube boundary
            // {   8, 1, 14, 0x1E0000,   0,    false,    },       // cube boundary


            // top facets

            {   9, 2,  4+(23-(17-1)), 0x0D0000-0x10000,   0,    true,    },
            {   9, 2,  4+(23-(11-1)), 0x100000-0x10000,   1,    true,    },
            {   9, 1,  4+(23-(20-1)), 0x140000-0x10000,   2,    true,    },
            {   9, 5,  4+(23-( 5-1)), 0x130000-0x10000,   3,    true,    },
            {   9, 4,  4+(23-(14-1)), 0x170000-0x20000,   4,    true,    },
            {   9, 7,  4+(23-( 8-1)), 0x1A0000-0x10000,   6,    true,    },
            {   9, 3,  4+(23-(23-1)), 0x1C0000-0x20000,   5,    true,    },
            {   9, 6,  4+(23-(17-1)), 0x1F0000-0x20000,   7,    true,    },
            {   9, 1,  4+(23-(11-1)), 0x220000-0x20000,   8,    true,    },

            // right facets

            {   10, 3,   4+(23-(5-1)), 0x110000-0x20000,   6,    false,   },       // L0
            {   10, 1,   4+(23-(8-1)), 0x190000-0x30000,   7,    false,   },       // L1
            {   10, 6,  4+(23-(11-1)), 0x200000-0x20000,   8,    false,   },       // L2 (@CENTER)

            // left facets

            {   11, 6,  4+(23-(23-1)), 0x1C0000-0x20000,   6,    false,   },
            {   11, 1,  4+(23-(17-1)), 0x1F0000-0x20000,   7,    false,   },
            {   11, 3,  4+(23-(11-1)), 0x220000-0x20000,   8,    false,   },

            {   -1,  0,0,0,    false,   },
        },




    },
};


int visibleFace[] = {
    0, 3, 1,
};



/*
            B/2
           +--+--+--+
           |15|16|17|
           +--+--+--+
           |12|13|14|
           +--+--+--+
           | 9|10|11|
           +--+--+--+
 A/0        C/3        E/5        F/6
+--+--+--+ +--+--+--+ +--+--+--+ +--+--+--+
| 6| 7| 8| |24|25|26| |42|43|44| |51|52|53|
+--+--+--+ +--+--+--+ +--+--+--+ +--+--+--+
| 3| 4| 5| |21|22|23| |39|40|41| |48|49|50|
+--+--+--+ +--+--+--+ +--+--+--+ +--+--+--+
| 0| 1| 2| |18|19|20| |36|37|38| |45|46|47|
+--+--+--+ +--+--+--+ +--+--+--+ +--+--+--+
            D/4
           +--+--+--+
 27 30 33  |33|34|35|
           +--+--+--+
 28 31 34  |30|31|32|
           +--+--+--+
 29 32 35  |27|28|29|
           +--+--+--+
*/



int stickerColour[][9] = {

    { 1,1,1,1,7,1,1,1,1 },
    { 2,2,2,2,2,2,6,6,6 },
    { 3,3,3,3,3,3,3,3,3 },
    { 1,1,1,1,7,1,1,1,1 },
    { 2,2,2,2,2,2,6,6,6 },
    { 3,3,3,3,3,3,3,3,3 },
};


const unsigned char *shapeMarker[] = {
    &marker[0],
    &marker[0],
    &marker[0],
    &marker[0],
    &marker[0],
    &marker[0],
    &marker[0],
    &marker[0],
};


const unsigned char *shapeSetTop[] = {
    // rotation 0
    &topFacets000[0],
    &topFacets001[0],
    &topFacets010[0],
    &topFacets011[0],
    &topFacets100[0],
    &topFacets101[0],
    &topFacets110[0],
    &topFacets111[0],
};

const unsigned char *shapeSetTop2[] = {
    // rotation 0
    &top2Facets000[0],
    &top2Facets001[0],
    &top2Facets010[0],
    &top2Facets011[0],
    &top2Facets100[0],
    &top2Facets101[0],
    &top2Facets110[0],
    &top2Facets111[0],
};

const unsigned char *shapeSetTop3[] = {
    // rotation 0
    &top3Facets000[0],
    &top3Facets001[0],
    &top3Facets010[0],
    &top3Facets011[0],
    &top3Facets100[0],
    &top3Facets101[0],
    &top3Facets110[0],
    &top3Facets111[0],
};

const unsigned char *shapeSetTop45[] = {
    // rotation 0
    &topFacet45_000[0],
    &topFacet45_001[0],
    &topFacet45_010[0],
    &topFacet45_011[0],
    &topFacet45_100[0],
    &topFacet45_101[0],
    &topFacet45_110[0],
    &topFacet45_111[0],
};

const unsigned char *shapeSetFront45[] = {
    // rotation 0
    &frontFacet45_000[0],
    &frontFacet45_001[0],
    &frontFacet45_010[0],
    &frontFacet45_011[0],
    &frontFacet45_100[0],
    &frontFacet45_101[0],
    &frontFacet45_110[0],
    &frontFacet45_111[0],
};


const unsigned char *shapeSetRight[] = {
    &rightFacets000[0],
    &rightFacets001[0],
    &rightFacets010[0],
    &rightFacets011[0],
    &rightFacets100[0],
    &rightFacets101[0],
    &rightFacets110[0],
    &rightFacets111[0],
};

const unsigned char *shapeSetRight2[] = {
    &right2Facets000[0],
    &right2Facets001[0],
    &right2Facets010[0],
    &right2Facets011[0],
    &right2Facets100[0],
    &right2Facets101[0],
    &right2Facets110[0],
    &right2Facets111[0],
};

const unsigned char *shapeSetRight3[] = {
    &right3Facets000[0],
    &right3Facets001[0],
    &right3Facets010[0],
    &right3Facets011[0],
    &right3Facets100[0],
    &right3Facets101[0],
    &right3Facets110[0],
    &right3Facets111[0],
};

const unsigned char *shapeSetLeft[] = {
    &leftFacets000[0],
    &leftFacets001[0],
    &leftFacets010[0],
    &leftFacets011[0],
    &leftFacets100[0],
    &leftFacets101[0],
    &leftFacets110[0],
    &leftFacets111[0],
};

const unsigned char *shapeSetLeft2[] = {
    &left2Facets000[0],
    &left2Facets001[0],
    &left2Facets010[0],
    &left2Facets011[0],
    &left2Facets100[0],
    &left2Facets101[0],
    &left2Facets110[0],
    &left2Facets111[0],
};

const unsigned char *shapeSetLeft3[] = {
    &left3Facets000[0],
    &left3Facets001[0],
    &left3Facets010[0],
    &left3Facets011[0],
    &left3Facets100[0],
    &left3Facets101[0],
    &left3Facets110[0],
    &left3Facets111[0],
};

const unsigned char *shapeBoundary[] = {
    &cubeBoundary[0],
    &cube1Boundary[0],
    &cubeBoundary[0],
    &cubeBoundary[0],
    &cubeBoundary[0],
    &cubeBoundary[0],
    &cubeBoundary[0],
    &cubeBoundary[0],
};


void drawSoftwareSprites() {

    int rr = rotateTop[fLayer];
//    if (JOY0_FIRE || fLayer == 2)
//        rr = rotateTop[0];

    struct facet *f = &shapeDef[0][rr][fno++];

    // no more facets --> finished drawing
    if (f->face < 0) {

        fno = 0;


        if (++fLayer > 2) {
            fLayer = 0;


            if (highlightLayer) {
                highlightLayer--;
                showHighlight=  true;
            }

            else
                showHighlight = false;

            for (int l = 0; l < 3; l++) {

                if (rotateSpeed[l])
                    rotateSpeed[l]--;
    
                if (!rotateSpeed[l]) {

                    rotateSpeed[l] = 20;

                    rotateTop[l]+= direct[l];
                    rotateTop[l] &= 15;

                    if (!(rotateTop[l] & 3))
                        direct[l] = 0;

                }


                // if (!(direct[l] + rotateSpeed[l])) {
                //     direct[l] = ((getRandom32() >> 12) & 0xFF) >= 0x80? -1 : 1;
                //     rotateSpeed[l] = (getRandom32() & 15) + 1;


                // }



            }

            // drawBitmap(highlighter,
            //     ((0 << 14) & 0xFFFFC000) + 0x0000C000,
            //     (((130 - (fLayer * 13) << 16) + (20)) & 0xFFFF0000)  * 3,
            //     true);

            finished = true;
        }


        return;

    }


    const unsigned char **shape;
    switch (f->face) {
    case 0: shape = shapeSetTop;
        break;
    case 1: shape = shapeSetLeft;
        break;
    case 2: shape = shapeSetRight;
        break;
    case 3: shape = shapeSetTop45;
        break;
    case 4: shape = shapeSetFront45;
        break;
    case 5: shape = shapeSetRight2;
        break;
    case 6: shape = shapeSetLeft2;
        break;
    case 7: shape = shapeSetTop2;
        break;
    case 8: shape = shapeBoundary;
        break;
    case 9: shape = shapeSetTop3;
        break;
    case 10: shape = shapeSetLeft3;
        break;
    case 11: shape = shapeSetRight3;
        break;
    case 12: shape = shapeMarker;
        break;
    }

    #if MARKER
        shape = shapeMarker;
    #endif


    int theColour = f->colour;
    if (showHighlight && fLayer == controlledLayer && !(highlightLayer & 1))
        theColour = 0;

    if (!f->topOnly || (fLayer == 2 && f->topOnly))
        drawBitmap(shape[theColour], //f->colourstickerColour[f->face][fLayer * 3 + f->square]],
            ((f->x << 14) & 0xFFFFC000) + 0x00024000,
            (((130 - (fLayer * 13) << 16) + (f->y)) & 0xFFFF0000)  * 3,
            true);



    // return;



    int cube = sortOrder[cubePtr];


    // if ((getRandom32() & 0xFF) < 10)
    //     if (getRandom32() & 1)
    //         spaceShipShape[cube] = &eroShip[0];
    //     else
    //         spaceShipShape[cube] = &eroShip2[0];

    // spaceShipShape[cube] = &topFace[0];



    #if 0

    // functional normal cube...

    if (hasTopFace[cube]) {

        const unsigned char *facetTopColour[] = {
            &topFacets000[0],
            &topFacets001[0],
            &topFacets010[0],
            &topFacets011[0],
            &topFacets100[0],
            &topFacets101[0],
            &topFacets110[0],
            &topFacets111[0],
        };

        if ((getRandom32() & 0xff) < 28) {
            int fcol = getRandom32() & 7;
            if (fcol > 0 && fcol < 7 && fcol != spaceshipRightShape[cube] && fcol != spaceshipLeftShape[cube])
                spaceshipTopShape[cube] = fcol;
        }

        drawBitmap(facetTopColour[spaceshipTopShape[cube]],
            (spaceshipX[cube] & 0xFFFFC000) + 0x00024000,
            (((103 << 16) + spaceshipY[cube]) & 0xFFFF0000)  * 3,
            true);
    }

    // drawBitmap(&innerFacets[0],
    //     (spaceshipX[cube] & 0xFFFFC000) + 0x00024000,
    //     (((104 << 16) + spaceshipY[cube]) & 0xFFFF0000)  * 3,
    //     true);

    if (hasRightFace[cube]) {

        const unsigned char *facetRightColour[] = {
            &rightFacets000[0],
            &rightFacets001[0],
            &rightFacets010[0],
            &rightFacets011[0],
            &rightFacets100[0],
            &rightFacets101[0],
            &rightFacets110[0],
            &rightFacets111[0],
        };

        if ((getRandom32() & 0xff) < 28) {
            int fcol = getRandom32() & 7;
            if (fcol > 0 && fcol < 7 && fcol != spaceshipLeftShape[cube] && fcol != spaceshipTopShape[cube])
                spaceshipRightShape[cube] = fcol;
        }

        drawBitmap(facetRightColour[spaceshipRightShape[cube]],
            (spaceshipX[cube] & 0xFFFFC000) + 0x00024000,
            (((104 << 16) + spaceshipY[cube]) & 0xFFFF0000)  * 3,
            true);
    }

    if (hasLeftFace[cube]) {

        const unsigned char *facetLeftColour[] = {
            &leftFacets000[0],
            &leftFacets001[0],
            &leftFacets010[0],
            &leftFacets011[0],
            &leftFacets100[0],
            &leftFacets101[0],
            &leftFacets110[0],
            &leftFacets111[0],
        };

        if ((getRandom32() & 0xff) < 28) {
            int fcol = getRandom32() & 7;
            if (fcol > 0 && fcol < 7 && fcol != spaceshipRightShape[cube] && fcol != spaceshipTopShape[cube])
                spaceshipLeftShape[cube] = fcol;
        }

        drawBitmap(facetLeftColour[spaceshipLeftShape[cube]],
            (spaceshipX[cube] & 0xFFFFC000) + 0x00024000,
            (((104 << 16) + spaceshipY[cube]) & 0xFFFF0000)  * 3,
            true);
    }



    #endif

    #if 0

    if (hasTopFace[cube]) {

        const unsigned char *facetTopColour[] = {
            &topFacet45_000[0],
            &topFacet45_001[0],
            &topFacet45_010[0],
            &topFacet45_011[0],
            &topFacet45_100[0],
            &topFacet45_101[0],
            &topFacet45_110[0],
            &topFacet45_111[0],
        };

        const int ssx[] = {

            0,0,0,0,
            0,0,0,0,
            0,0,

            2+6, 9+6, 16+6,
            2+6, 9+6, 16+6,
            2+6, 9+6, 16+6,

        };

        const int ssy[] = {

            0,0,0,0,
            0,0,0,0,
            0,0,

            0x190000+0x0e0000, 0x190000+0x0e0000, 0x190000+0x0e0000,
            0x220000+0x0e0000, 0x220000+0x0e0000, 0x220000+0x0e0000,
            0x2b0000+0x0e0000, 0x2b0000+0x0e0000, 0x2b0000+0x0e0000,
        
        };





        if ((getRandom32() & 0xff) < 28) {
            int fcol = getRandom32() & 7;
            if (fcol > 0 && fcol < 7 && fcol != spaceshipRightShape[cube] && fcol != spaceshipLeftShape[cube])
                spaceshipTopShape[cube] = fcol;
        }

        drawBitmap(facetTopColour[spaceshipTopShape[cube]],
            ((ssx[cube] << 14) & 0xFFFFC000) + 0x00024000,
            (((90 << 16) + ssy[cube]) & 0xFFFF0000)  * 3,
            true);
    }

    #endif

    if (++cubePtr >= SPACESHIPS) {
        cubePtr = 0;
    }




}




void GameScheduleDrawSprites() {


    setDisplayPalette();
//    drawScore();


  //  for (int sp = 0; sp < 1; sp++) {

        // if (finished) {
        //     pfBuffer ^= 1;
        //     drawScreen();
        //     finished = false;
        //     break;
        // }

        // drawSoftwareSprites();
    //}

 //   doPlayer();


//    lastDisplayMode = displayMode;

}



#define ROW_MAXIMUM 23

char boardRow;
unsigned char boardCol;

int changeAmoebaToBoulder;

void SetupBoard() {

    if (frameCounter > gameSpeed) {

        lastDripFree = dripFree;
        dripFree = true;

        frameCounter = 0;
        toggler++;

        boardCol = -1;
        boardRow = ROW_MAXIMUM;

        changeAmoebaToBoulder = amoebaCounter;
        amoebaCounter = 0;

        lastAmoebaGrew = amoebaGrew;
        amoebaGrew = 0;

        gameSchedule = SCHEDULE_PROCESSBOARD;

    }
}



void InitGameBuffers() {
    
    // set the Jump Datastream so each entry runs the NORMAL KERNEL by default
    // init Jump Datastream
    for (int i=0; i < _ARENA_SCANLINES; i++)
        RAM_SINT[(_BUF_JUMP1 / 2) + i] = _NORMAL_KERNEL;
    RAM_SINT[ _BUF_JUMP1_EXIT / 2 ] = _EXIT_KERNEL;
}





void moveRockford(unsigned char *this, unsigned char blanker) {

#if 0

    static const unsigned char direct[] = {
        DIR_UP,
        DIR_DOWN,
        DIR_LEFT,
        DIR_RIGHT,
    };

    static const int offsetD[] = {
        -40,
        +40,
        -1,
        +1,
    };

    static const int faceDirection[] = {
        0,
        0,
        LEFT,
        RIGHT,
    };

    static const int newAnim[] = {
        ID_WALK_VERT,
        ID_WALK_VERT_DOWN,
        ID_WALK,
        ID_WALK,
    };

    static const char newSnatch[] = {
        ID_SNATCH_UP,
        ID_SNATCH_DOWN,
        ID_SNATCH,
        ID_SNATCH,
    };


    if (exitMode)
        return;


#define DIRT_DIRT 0x80
#define DIRT_DOGE 0x40

    unsigned char dirtFlag = 0;

// exitTrigger = true; //tmp

    for (int dir = 0; dir < 4; dir++ ) {

        int offset = offsetD[dir];

        if ((bufferedSWCHA & (direct[dir] << 4)) == 0) {       // direction button?

//                    setFlash(0x46,1);

            unsigned char destType = CharToType[*(this+offset) & (0x7F|0x80)];  // dubious masking of FLAG

            bufferedSWCHA = 0xFF; //|= (direct[dir] << 4);

            if (faceDirection[dir]) {
                if (rockfordDirection != faceDirection[dir]) {
                    pushCounter = 0;
                    rockfordDirection = faceDirection[dir];
                }
            }

            if (Attribute[destType] & (ATT_BLANK | ATT_PERMEABLE | ATT_GRAB | ATT_EXIT)) {
            
                pushCounter = 0;

                if (destType == TYPE_DIRT
                    ||destType == TYPE_DIRT2
                    ||destType == TYPE_DIRT3) {
                        AddAudio(SFX_DIRT);
                        dirtFlag = DIRT_DIRT;
                        //AnimIdx[TYPE_DUST] = 0;
                }

                if (destType == TYPE_BLANK)
                    AddAudio(SFX_SPACE);

                if (destType == TYPE_OUTBOX) {
                    exitMode = true;
                    setAnimation(ID_SHAKE); //? fail
                }

                if (Attribute[destType] & ATT_GRAB) {

                    addScore(doge? diamondValue: extraDogeCoinValue);

                    if (doge) {
                        if (!--doge) {
                            setFlash(0x0F, 4);     //open door
                            exitTrigger = true;
                            AddAudio(SFX_EXIT);
                        }
                    }


                    dogeCollected++;
                    diamondGrabTime = 10;
                    dirtFlag = DIRT_DOGE;

                    AddAudio(SFX_DOGE);
                }

                if (JOY0_FIRE) {

                    if (Attribute[destType] & (ATT_GRAB | ATT_PERMEABLE)
                        && !(Attribute[destType] & ATT_BLANK)) {  // snatch?
                        *(this+offset) = (
                               (destType == TYPE_DIRT)
                            || (destType == TYPE_DIRT2)
                            || (destType == TYPE_DIRT3)
                            ? CH_DUST : CH_DOGE_GRAB) ; // | FLAG_THISFRAME;
                        diamondGrabTime = 1;
                        setAnimation(newSnatch[dir]);
                    }
                    else
                    {
                        setAnimation(ID_JUMP);
                    }
                    
                }

                else {

                    rockfordX += xInc[direct[dir]];
                    rockfordY += yInc[direct[dir]];

                    frameAdjustX = frameAdjustY = 0;

                    *(this+offsetD[dir]) = CH_ROCKFORD ; // | FLAG_THISFRAME;
                    *this = (dirtFlag == DIRT_DIRT ? CH_DUST : blanker) ; // | FLAG_THISFRAME;

                    if (dirtFlag & DIRT_DIRT) {
                        AnimIdx[TYPE_ROCKFORD].index = -2;
                        AnimIdx[TYPE_ROCKFORD].count = 0;
                    }

                    if (dirtFlag & DIRT_DOGE) {
                        AnimIdx[TYPE_ROCKFORD].index = 6;
                        AnimIdx[TYPE_ROCKFORD].count = 0;
                    }

                    int anim = newAnim[dir];
                    //if (anim == ID_WALK && dirtFlag)
                    //    anim = ID_PUSHWALK;

                    setAnimation(anim);
                }


            } else {

                if (faceDirection[dir] && (Attribute[destType] & ATT_PUSH)) {

                    pushCounter++;

                    if (pushCounter > 1)
                        setAnimation(ID_PUSH);
                    else
                        setAnimation(ID_JUMP);


                    if (pushCounter > 20 || (pushCounter > 5 && (getRandom32() & 7) < 2)) { 
                        if (Attribute[CharToType[(*(this+ 2 * offset))&(0x7F|0x80) ]] & ATT_BLANK) {

                            halt = DELAY_AFTER_PUSH;
                            pushCounter = 0;

                            *(this + 2 * offset) = CH_BOULDER ; // | FLAG_THISFRAME;
                            if (JOY0_FIRE)
                                *(this+offset) = blanker ; // | FLAG_THISFRAME;
                            else {
                                rockfordX += offset;
                                *(this+offset) = CH_ROCKFORD ; // | FLAG_THISFRAME;
                                *this = blanker ; // | FLAG_THISFRAME;
                            }

                            AddAudio(SFX_PUSH);

                        }
                    }
                }

                else
                    setAnimation(ID_JUMP);
            }

            return;
        }
    }

    // no direction was detected...

    pushCounter = 0;

    if (*(this-40) == (CH_DOGE_FALLING ; // | FLAG_THISFRAME)
        || *(this-40) == (CH_BOULDER_FALLING ; // | FLAG_THISFRAME))
            setAnimation(ID_DIE);

    else {

        playerAnimationLoop = 0;                   // bypass any looping!

        static const unsigned char animID[] = {
            ID_BLINK,       200, 
            ID_WIPE_HAIR,   20,
            ID_IMPATIENT,   12, 
            ID_TURN,        17, 
            ID_LOOK,        30, 
            ID_SHADES,      25, 
            ID_ARMSCROSSED, 13,
        };

        // choose an idle animation

        unsigned int rnd = getRandom32();
        if (playerAnimationID == ID_STAND && (rnd & 0xFF) < 0x60) {
            rnd = getRandom32();
            int idle = ((rnd & 0xFF * 7) >> 8) << 1; 
            rnd = getRandom32();
            if ((rnd & 0x3FF) < animID[idle + 1])
                setAnimation(animID[idle]);
                
        }
    }
#endif

}


void fixRock(unsigned char *rock) {


    unsigned char linkage = CH_ROCK0;

    if (CharToType[*(rock+1)] == TYPE_ROCK)
        linkage += 1;
    if (CharToType[*(rock+40)] == TYPE_ROCK)
        linkage += 2;
    if (CharToType[*(rock-1)] == TYPE_ROCK)
        linkage += 4;
    if (CharToType[*(rock-40)] == TYPE_ROCK)
        linkage += 8;

    *rock = linkage;
}


void doRoll(unsigned char *this, unsigned int creature) {


    if (boardRow > ROW_MAXIMUM - 3)
        return;

    unsigned char _DOWN = CharToType[*(this + 40)&(0x7F|0x80)];
    unsigned char *LEFTWARDS = this - 1;
    unsigned char *RIGHTWARDS = this + 1;

    unsigned char c = creature == CH_DOGE ? CH_DOGE : CH_ROCK0;


#if ENABLE_SHAKE
    if (Attribute[_DOWN] & ATT_ROLL
        || (shakeTime && (getRandom32() & 0xFF) < 10)) {
#else
    if (Attribute[_DOWN] & ATT_ROLL) {
#endif

        if (boardCol > 0 && (Attribute[CharToType[*LEFTWARDS]] & ATT_ROCKFORDYBLANK)) {

            unsigned char lowerLeft = *(LEFTWARDS + 40);
            unsigned char typeLL = CharToType[lowerLeft];
            unsigned char typeL = CharToType[*LEFTWARDS];

            if (CharToType[creature] == TYPE_ROCK
                && ((typeLL == TYPE_ROCKFORD && (Attribute[typeL] & ATT_BLANK))
                || (typeL == TYPE_ROCKFORD && (Attribute[typeLL] & ATT_BLANK))))
                    *this = CH_BOULDER_SHAKE;

            else if (Attribute[typeL] & Attribute[typeLL] & ATT_BLANK) {
//                KillAudio(SFX_SHAKE);
                AddAudio(SFX_PUSH);    
                *LEFTWARDS = CH_ROCK0; //BOULDER_FALLING; // | FLAG_THISFRAME;
                *this = CH_BLANK ; // | FLAG_THISFRAME;
                thisFrame[1][boardCol-1] = true;
                return;
            }
        }
        
        if (boardCol < 39
            && (Attribute[CharToType[*RIGHTWARDS]] & ATT_ROCKFORDYBLANK)) {

            unsigned char lowerRight = *(RIGHTWARDS + 40);
            unsigned char typeLR = CharToType[lowerRight];
            unsigned char typeR = CharToType[*RIGHTWARDS];

            if (CharToType[creature] == TYPE_ROCK &&
                ((typeLR == TYPE_ROCKFORD && (Attribute[typeR] & ATT_BLANK))
                || (typeR == TYPE_ROCKFORD && (Attribute[typeLR] & ATT_BLANK)))
                )
                    *this = CH_BOULDER_SHAKE;

            else if (Attribute[typeR] & Attribute[typeLR]  & ATT_BLANK) {

//                KillAudio(SFX_SHAKE);
                AddAudio(SFX_PUSH);    

                *RIGHTWARDS = CH_ROCK0; //CH_BOULDER_FALLING; // | FLAG_THISFRAME;
                *this = CH_BLANK ; // | FLAG_THISFRAME;
                thisFrame[0][boardCol+1] = true;

                return;
            }
        }

        if (creature == CH_BOULDER_SHAKE)
            *this = CH_ROCK0;

    }

    //else if (creature == CH_BOULDER_SHAKE)
    //    *this = CH_BOULDER;

}


const int dir[] = { -1, 
1, -40, 40, -41, 41, -39, 39 };


void GameScheduleProcessBoardRow() {

    if (!finished)
        drawSoftwareSprites();

}




const char AnimPreOut[] = {
    CH_DOORCLOSED,255,
};

const char AnimFlashOut[] = {

    CH_DOOROPEN_0,20,
    CH_DOOROPEN_1,20,
//    CH_BLANK,254,
    255
};


const char AnimBoulderShake[] = {
    CH_BOULDER_SHAKE,3,
    CH_ROCK0,3,
    255
};


const char AnimDogeCoin[] = {
    
    CH_DOGE,8,
    CH_DOGE_PULSE_1,6,
    CH_DOGE_PULSE_2,4,
    CH_DOGE_PULSE_3,3,
    CH_DOGE_PULSE_4,3,
    CH_DOGE_PULSE_5,4,
    CH_DOGE,8,
    CH_DOGE_PULSE_5,4,
    CH_DOGE_PULSE_4,3,
    CH_DOGE_PULSE_3,3,
    CH_DOGE_PULSE_2,4,
    CH_DOGE_PULSE_1,6,
    CH_DOGE,8,
    255,
};


const char AnimEgg[] = {
    CH_EGG, 30,
    CH_EGG2, 20,
    255,
};


const char AnimZzapUP[] = {
    CH_ZZAP, 14,
    CH_ZZAP2, 14,
    CH_ZZAP1, 14,
    255,
};

const char AnimZzapDOWN[] = {
    CH_ZZAP1, 8,
    CH_ZZAP2, 8,
    CH_ZZAP, 8,
    255,
};

const char AnimDrill[] = {
    CH_DRILL2, 8,
    CH_DRILL1, 8,
    CH_DRILL, 8,
    255,
};



const char AnimRockford[] = {

    CH_DUST, 8,
    CH_DUST2, 8,
    CH_DUST3, 8,
    CH_ROCKFORD,255,

    CH_DOGE, 3,
    CH_DOGE_GRAB,5,
    CH_ROCKFORD,255,

};

const char AnimDrip[] = {
    CH_DRIP, 3,
    CH_BLANK_ALTERNATE_3, 3,
    CH_DRIP, 3,
    CH_BLANK_ALTERNATE_3, 3,
    CH_DRIP, 22,

    CH_DRIP1, 6,
    CH_DRIP2, 5,
    CH_DRIP3, 3,
    CH_DRIP3, 1,

    CH_DRIP1, 4,
    CH_DRIP2, 4,
    CH_DRIP3, 3,
    CH_DRIP3, 255
};

const char AnimDripSplash[] = {
    CH_DRIPX, 4,
    CH_BLANK_ALTERNATE_3, 2,
    CH_DRIPX, 1,
    CH_BLANK_ALTERNATE_3, 255,
};


const char AnimBlank[] = {
    CH_BLANK, 255,
};

const char AnimBelt[] = {

    CH_BELT, 5,
    CH_BELT1, 5,
    CH_BELT2, 5,
    CH_BELT3, 5,
    255,
};

const char AnimBelt2[] = {

    CH_BELT3, 9,
    CH_BELT2, 9,
    CH_BELT1, 9,
    CH_BELT, 9,
    255,
};



const char (*Animate[TYPE_MAX])[] = {

    // indexed by object TYPE
    // 0 if the object does not animate

    0,                          // 00 BLANK_PARALLAX
    &AnimBlank,                 // 01 BLANK
    0,                          // 02 DIRT            
    0,                          // 03 BRICKWALL       
    &AnimPreOut,                // 04 OUTBOX_PRE      
    &AnimFlashOut,              // 05 OUTBOX          
    0,                          // 06 BOULDER_FALLING 
    0,                          // 07 STEELWALL       
    0,                          // 08 BOULDER         
    &AnimDogeCoin,              // 09 DOGE            
    0,                          // 10 EXPLODE_SPACE_0 
    0,                          // 11 EXPLODE_SPACE_1 
    0,                          // 12 EXPLODE_SPACE_2 
    0,                          // 13 EXPLODE_SPACE_3 
    0,                          // 14 EXPLODE_SPACE_4 
    0,                          // 15 EXPLODE_DOGE_0  
    0,                          // 16 EXPLODE_DOGE_1  
    0,                          // 17 EXPLODE_DOGE_2  
    0,                          // 18 EXPLODE_DOGE_3  
    0,                          // 19 EXPLODE_DOGE_4  
    0,                          // 20 ROCKFORD_PRE    
    &AnimRockford,              // 21 ROCKFORD        
    0,                          // 22 AMOEBA          
    &AnimDrip,                  // 23 DRIP            
    &AnimDripSplash,            // 24 DRIP_SPLASH     
    0,                          // 25 __NOTHING       
    0,                          // 26 EXPLODE_THIS    
    0,                          // 27 BLANK_THIS      
    0,                          // 28 DIRT3           
    0,                          // 29 DIRT2           
    0,                          // 30 EXPLODE_BLANK_0 
    0,                          // 31 EXPLODE_BLANK_1 
    0,                          // 32 EXPLODE_BLANK_2 
    0,                          // 33 EXPLODE_BLANK_3 
    0,                          // 34 EXPLODE_BLANK_4 
    0,                          // 35 DOGE_GRAB       
    0,                          // 36 DIRT_GRAB       
    0,                          // 37 DUST            
    0,                          // 38 DUST2           
    0,                          // 39 DUST3           
    &AnimBoulderShake,          // 40 BOULDER_SHAKE   
    0,                          // 41 DUST_LEFT       
    0,                          // 42 DUST2_LEFT      
    0,                          // 43 DUST3_LEFT      
    0,                          // 44 DUST_RIGHT      
    0,                          // 45 DUST2_RIGHT     
    0,                          // 46 DUST3_RIGHT     
    0,                          // 47 LAVA            
    0,                          // 48 WATER           
    &AnimEgg,                   // 49 EGG             
    &AnimZzapUP,                // 50 ZZAP            
    &AnimZzapDOWN,              // 51 ZZAP1           
    0,                          // 52 ROCK            
    &AnimDrill,                 // 53 DRILL
    0,                          // 54 DRILLBODY           
    &AnimBelt,                  // 55 BELT
    &AnimBelt2,                 // 56 BELT2
};




void processAnimationCommand() {

    while (playerAnimationCount == 0)
        switch (*playerAnimation) {

        case FRAME_FLIP:
            rockfordDirection = -rockfordDirection;
            playerAnimation++;
            break;

        case FRAME_LOOP:
            if (playerAnimationLoop)
                playerAnimation = playerAnimationLoop;
            else {
                playerAnimation++;            
                playerAnimationLoop = 0;
            }
            break;

        case FRAME_STOP:
            playerAnimationID = -1;
            setAnimation(ID_STAND);
            break;

        case FRAME_ADJUST: {
            frameAdjustX = *++playerAnimation;
            frameAdjustY = *++playerAnimation;
            frameAdjustSmallX = *++playerAnimation;
            frameAdjustSmallY = *++playerAnimation;
            playerAnimation++;
        }
            break;

        default:
            playerAnimationCount = (*(playerAnimation+1)) * DEBUG_SLOWDOWN;
            break;

        }
}


void updateAnimation() {

    if (playerAnimationCount)
        playerAnimationCount--;
    else {
        playerAnimation += 2;
        processAnimationCommand();
        playerAnimationCount--;
    }
}

void setAnimation(int animID) {

    if (playerAnimationID != animID) {
        playerAnimationID = animID;
        playerAnimation = playerAnimationLoop = animIndex[animID];
//        if (playerAnimationLoop < 0)
//            playerAnimationLoop = 0;
        playerAnimationCount = 0;

        processAnimationCommand();

        //frameAdjustX = 0;
        //frameAdjustY = 0;
    }
}



// EOF
